{
  "hash": "58d08b0183b3e6d6779c3e39a961c5c4",
  "result": {
    "markdown": "---\nalways_allow_html: true\ntitle: \"3 Objetos em R\"\n---\n\n\n## 3.1 Vetores em R\nVamos recapitular um pouco do que vimos anteriormento sobre vetores. Os vetores são um bloco de construção básica para programação em R. Vetores são muito versáteis, formando a base para construções mais complexas, como matrizes, listas e data frames. Eles desempenham um papel central na manipulação de dados.\n\nUm vetor é uma estrutura de dados fundamental que consiste em uma **sequência ordenada de elementos do mesmo tipo**. Esses elementos podem ser números inteiros, números de ponto flutuante, caracteres, valores lógicos ou qualquer outro tipo de dado.\n\nEm termos mais simples, **um vetor é como uma “caixa” que pode conter vários valores do mesmo tipo**. Cada valor dentro do vetor é chamado de elemento. Os elementos de um vetor podem ser acessados individualmente por meio de um índice que indica sua posição na sequência. Em R o primeiro elemento de um vetor é acessado pelo índice `[1]`, em outras linguagens, como em Python, esse índice é `[0]`.\n\n### 3.1.1 Criação de Vetores e Manipulação de Propriedades\nUm vetor em R é uma sequência ordenada de elementos do mesmo tipo. Você pode criar um vetor usando a função `c()`, que combina elementos em um único vetor. Por exemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Criando um vetor de números inteiros\nvetor_inteiro <- c(2, 4, 6, 8, 10)\n\n# Criando um vetor de números reais\nvetor_real <- c(3.14, 1.618, 2.718, 3.48, 1.9)\n\n# Criando um vetor de caracteres\nvetor_caracteres <- c(\"maçã\", \"banana\", \"laranja\")\n\n# Criando um vetor misto\nvetor_misto <- c(1, 2, \"maçã\", \"banana\", \"laranja\")\n```\n:::\n\n\nPara sabermos o comprimento de um vetor utilizamos a função `length()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vetor_inteiro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vetor_real)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vetor_caracteres)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vetor_misto)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nPara sabermos a classe de um vetor utilizamos a função `class()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(vetor_inteiro)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(vetor_real)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(vetor_caracteres)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(vetor_misto)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n### 3.1.2 Operações Aritméticas Vetoriais\nOperações aritméticas em vetores são realizadas elemento por elemento, facilitando cálculos eficientes. Por exemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Soma de vetores\nsoma_vetores <- vetor_inteiro + vetor_real\nsoma_vetores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5.140  5.618  8.718 11.480 11.900\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subtração de vetores\nsubtracao_vetores <- vetor_real - vetor_inteiro\nsubtracao_vetores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.140 -2.382 -3.282 -4.520 -8.100\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiplicação de vetores\nmultiplicacao_vetores <- vetor_inteiro * 2\nmultiplicacao_vetores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  8 12 16 20\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Divisão de vetores\ndivisao_vetores <- vetor_real / 3\ndivisao_vetores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0466667 0.5393333 0.9060000 1.1600000 0.6333333\n```\n:::\n:::\n\n\n### 3.1.3 Aplicação da Regra da Reciclagem\nA regra da reciclagem permite aplicar operações entre **vetores de tamanhos diferentes**. Essa regra permite que vetores de tamanhos distintos sejam combinados de maneira coerente em operações **aritméticas ou lógicas**. O vetor menor é “reciclado” ou replicado várias vezes para se ajustar ao tamanho do vetor maior, permitindo que as operações sejam realizadas de forma consistente em todos os elementos.\n\nPara compreender melhor a regra da reciclagem, considere a seguinte operação:\n\n::: {.cell}\n\n```{.r .cell-code}\nvetor_a <- c(1, 2)\nvetor_b <- c(10, 20, 30)\nresultado <- vetor_a + vetor_b\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in vetor_a + vetor_b: comprimento do objeto maior não é múltiplo do\ncomprimento do objeto menor\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11 22 31\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vetor_a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(vetor_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\nNote que o vetor `vetor_a` tem apenas dois elementos, enquanto o vetor `vetor_b` tem três elementos. Ao realizar a operação de adição, a regra da reciclagem faz com que o vetor `vetor_a` seja **replicado** para corresponder ao tamanho do vetor `vetor_b`. Isso resulta em `vetor_a` transformado em `c(1, 2, 1)` e, então, a operação de adição é realizada elemento a elemento:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 1) + c(10, 20, 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11 22 31\n```\n:::\n:::\n\n\n\nVale ressaltar que a regra da reciclagem funciona quando o comprimento do vetor maior é um múltiplo inteiro do comprimento do vetor menor. Caso contrário, um aviso ou erro será gerado.\n\n### 3.1.4 Exploração de Vetores Lógicos\nVetores lógicos desempenham um papel crucial na programação e análise de dados, permitindo a seleção e filtragem de elementos com base em condições específicas. Um vetor lógico contém valores *booleanos* (`TRUE` ou `FALSE`), onde cada elemento **indica se uma determinada condição é verdadeira ou falsa para o elemento correspondente no vetor original**.\n\n#### 3.1.4.1 Aplicação de Vetores Lógicos: Filtragem e Seleção\n\nOs vetores lógicos são frequentemente usados para **filtrar** e **selecionar** elementos de um vetor com base em uma condição. Suponha que temos um vetor de idades e queremos selecionar apenas as idades maiores que 18:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidades <- c(16, 21, 14, 30, 25)\ncondicao <- idades > 18\ncondicao\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nidades_maiores <- idades[condicao]\nidades_maiores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21 30 25\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Também poderiamos incluir a condição \n## diretamente no vetor que queremos filtrar\n\nidades_maiores <- idades[idades > 18]\nidades_maiores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21 30 25\n```\n:::\n:::\n\n\n#### 3.1.4.2 Operações Lógicas em Vetores Lógicos\nAlém da filtragem, os vetores lógicos podem ser combinados com operações lógicas. Por exemplo, é possível usar operadores como `&` (AND) e `|` (OR) para criar condições mais complexas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidades <- c(16, 21, 14, 30, 25, 45)\ncondicao1 <- idades > 18\ncondicao2 <- idades < 30\ncondicao_final <- condicao1 & condicao2\nidades_selecionadas <- idades[condicao_final]\nidades_selecionadas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21 25\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Também poderiamos incluir a condição \n## diretamente no vetor que queremos filtrar\nidades_selecionadas <- idades[condicao_final]\nidades_selecionadas <- idades[idades > 18 & idades < 30]\n```\n:::\n\n\n### 3.1.5 Tratamento de Informações Faltantes\n\nAo lidar com dados do mundo real, é comum encontrar diversos tipos de informações faltantes, como valores ausentes (`NA`), valores que não são um número (`NaN`). O tratamento adequado desses valores é essencial para garantir a integridade das análises estatísticas.\n\n#### 3.1.5.1 Valores Ausentes (`NA`)\n\nO valor `NA` (*Not Available*) é usado em R para representar informações **ausentes**. É fundamental identificar e tratar esses valores ao realizar análises estatísticas.\n\n##### 3.1.5.1.1 Identificação de Valores NA\nPara identificar valores `NA`, você pode usar a função `is.na()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados <- c(1, NA, 3, 4, NA)\nvalores_faltantes <- is.na(dados)\n```\n:::\n\n\n##### 3.1.5.1.2 Remoção de Valores `NA`\n\nAs funções `na.omit()` e `na.exclude` removem os valores `NA` de um vetor, mas pode levar à perda de outros dados associados:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados <- c(1, NA, 3, 4, NA)\ndados_sem_na <- na.omit(dados)\ndados_sem_na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 4\nattr(,\"na.action\")\n[1] 2 5\nattr(,\"class\")\n[1] \"omit\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_sem_na_exclude <- na.exclude(dados)\ndados_sem_na_exclude\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 4\nattr(,\"na.action\")\n[1] 2 5\nattr(,\"class\")\n[1] \"exclude\"\n```\n:::\n:::\n\n\n##### 3.1.5.1.3 Preenchimento de Valores `NA`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados <- c(1, NA, 3, 4, NA)\ndados[is.na(dados)] <- 0\ndados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 3 4 0\n```\n:::\n:::\n\n\n#### 3.1.5.2 Valores que Não São um Número (`NaN`)\n\nO valor `NaN` (*Not a Number*) é usado para representar resultados matemáticos inválidos, como a **divisão por zero** ou a **raiz quadrada de um número negativo**.\n\n###### 3.1.5.2.1 Identificação de Valores `NaN`\n\nA função `is.nan()` identifica valores `NaN`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- 0 / 0\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_nao_eh_numero <- is.nan(resultado)\nvalor_nao_eh_numero\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### 3.1.6 Vetores nomeados\n\nPodemos atribuir um “nome” para cada elemento de um vetor. Com isso, podemos selecionar elementos nomeados do nosso vetor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidades <- c(20, 28, 35)\nnames(idades)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(idades) <- c(\"João\", \"Aline\", \"Márcio\") \nnames(idades)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"João\"   \"Aline\"  \"Márcio\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nidades\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  João  Aline Márcio \n    20     28     35 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nidades[\"Aline\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAline \n   28 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nidades[c(\"Aline\", \"João\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAline  João \n   28    20 \n```\n:::\n:::\n\n\n## 3.2 Matrizes\n\nAs **matrizes** e **arrays** são estruturas de dados **bidimensionais** e **multidimensionais**, respectivamente. Suas propriedades e funções permitem realizar uma variedade de operações, desde **cálculos matriciais** até resolução de **sistemas lineares e decomposições espectrais**.\n\n### 3.2.1 Criação e Manipulação de Matrizes em R\n\nA maneira mais simples para criarmos uma matriz em R é através das funções `cbind()` e `rbind()`, nas quais podemos concatenar vetores pelas colunas (*columns*) ou linhas (*rows*), respectivamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvetor_a = c(1,2,3,4)\nvetor_b = c(5,6,7,8)\n\nmatriz_linha = rbind(vetor_a, \n                     vetor_b)\nmatriz_linha\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        [,1] [,2] [,3] [,4]\nvetor_a    1    2    3    4\nvetor_b    5    6    7    8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(matriz_linha)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.matrix(matriz_linha)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatriz_coluna= cbind(vetor_a, \n                     vetor_b)\nmatriz_coluna\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     vetor_a vetor_b\n[1,]       1       5\n[2,]       2       6\n[3,]       3       7\n[4,]       4       8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(matriz_coluna)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.matrix(matriz_coluna)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nMatrizes também podem ser criadas através da função `matrix()`, que permite especificar os elementos, o número de linhas e colunas, e se os elementos devem ser preenchidos por linha ou por coluna.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1:9), \n            ncol = 3,\n            byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nB <- matrix(c(1:9), \n            ncol = 3, \n            byrow = FALSE)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n:::\n\n\n### 3.2.2 Seleção de Elementos em Matrizes no R\n\nA seleção de elementos em matrizes no R é uma operação fundamental para acessar e manipular dados específicos contidos na matriz. As técnicas de seleção permitem obter valores individuais, linhas, colunas ou subconjuntos da matriz com base em critérios específicos. Vamos explorar as diferentes formas de seleção de elementos em matrizes.\n\n#### 3.2.2.1 Seleção de Elementos Específicos\nPodemos selecionar elementos específicos de uma matriz informando o número da linha e da coluna correspondentes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(2, -1, 3, \n              1, 4, 1, \n              5, -2, 7), \n            ncol = 3, \n            byrow = TRUE)\nelemento_1_2 <- A[1, 2]  # Seleciona o elemento na primeira linha e segunda coluna \nelemento_1_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nelemento_3_3 <- A[3, 3]  # Seleciona o elemento na terceira linha e terceira coluna \nelemento_3_3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n#### 3.2.2.2 Seleção de Linhas ou Colunas Inteiras\nPodemos selecionar todas as entradas de uma linha ou coluna especificada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoluna_2 <- A[, 2]  # Seleciona a segunda coluna inteira \ncoluna_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1  4 -2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlinha_1 <- A[1, ]   # Seleciona a primeira linha inteira \nlinha_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2 -1  3\n```\n:::\n:::\n\n\n#### 3.2.2.3 Seleção com Base em Condições\n\nPodemos selecionar elementos com base em condições específicas. A função `which()` é útil para selecionar elementos em matrizes com base em condições específicas. Ela retorna os índices dos elementos que atendem à condição fornecida.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Exemplo 1: Seleção de Elementos Maiores que um Valor\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nelementos_maior_que_3 <- B[which(B > 3)]\nelementos_maior_que_3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 5 6 7 8 9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Exemplo 2: Seleção de Elementos Ímpares\nelementos_impares <- B[which(B %% 2 != 0)]\nelementos_impares\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5 7 9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Exemplo 3: Seleção de Elementos Negativos da Segunda Coluna\nelementos_negativos_coluna_2 <- A[, 2][which(A[, 2] < 0)] \nelementos_negativos_coluna_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1 -2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Exenplo 4: Seleção de Elementos por Linha\nelementos_linha_1_maior_que_2 <- B[1, which(B[1, ] > 2)]\nelementos_linha_1_maior_que_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 7\n```\n:::\n:::\n\n\n#### 3.2.2.4 Remoção de Linhas/Colunas (A[-linhas, -colunas])\n\nPodemos **remover** linhas ou colunas da matriz, criando uma nova matriz sem as linhas ou colunas especificadas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2   -1    3\n[2,]    1    4    1\n[3,]    5   -2    7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA_sem_terceira_coluna <- A[, -3]  # Remove a terceira coluna da matriz\nA_sem_terceira_coluna\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    2   -1\n[2,]    1    4\n[3,]    5   -2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA_sem_primeiras_duas_linhas <- A[-(1:2), ]  # Remove as duas primeiras linhas da matriz\n\nA_sem_primeiras_duas_linhas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5 -2  7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA_sem_linha_coluna <- A[-1, -2]  # Remove a primeira linha e segunda coluna\n\nA_sem_linha_coluna\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    1\n[2,]    5    7\n```\n:::\n:::\n\n\n### 3.2.3 Operações Matriciais e Funções de Matrizes\n\nAs operações matriciais e funções associadas desempenham um papel fundamental na manipulação e análise de dados em matrizes. Elas permitem realizar cálculos matemáticos essenciais para diversas aplicações, incluindo álgebra linear e estatísticas.\n\n#### 3.2.3.1 Soma e Subtração (A + B e A - B)\n\nA adição e subtração de matrizes envolvem a combinação de elementos correspondentes nas matrizes `A` e `B`. As **dimensões das matrizes devem ser compatíveis** para que essas operações sejam válidas. Para verificarmos a dimensão de uma matriz utilizamos a função `dim()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(4, -3, 7, \n              10, 1, 1, \n              -5, 2, 3), \n            ncol = 3, \n            byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4   -3    7\n[2,]   10    1    1\n[3,]   -5    2    3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(A) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nB <- matrix(c(2, -1, 3,\n              1, 4, 1, \n              5, -2, 7), \n            ncol = 3, \n            byrow = TRUE)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2   -1    3\n[2,]    1    4    1\n[3,]    5   -2    7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(B)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma <- A + B\nsoma\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    6   -4   10\n[2,]   11    5    2\n[3,]    0    0   10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(soma)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsubtracao <- A - B\nsubtracao\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2   -2    4\n[2,]    9   -3    0\n[3,]  -10    4   -4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(subtracao)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3\n```\n:::\n:::\n\n\n#### 3.2.3.2 Soma das Colunas (colSums(A)) e Soma das Linhas (rowSums(A))\n\nEssas funções retornam vetores com as somas das colunas e das linhas da matriz A, respectivamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_colunas_A <- colSums(A)\nsoma_colunas_A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  9  0 11\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_linhas_A <- rowSums(A)\nsoma_linhas_A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  8 12  0\n```\n:::\n:::\n\n\n#### 3.2.3.3 Média das Colunas (`colMeans()`) e Média das Linhas (`rowMeans()`)\nAs funções `colMeans()` e `rowMeans()` fornecem as médias das colunas e das linhas de uma matriz, respectivamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4   -3    7\n[2,]   10    1    1\n[3,]   -5    2    3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.000000 0.000000 3.666667\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrowMeans(B)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.333333 2.000000 3.333333\n```\n:::\n:::\n\n\n#### 3.2.3.4 Multiplicação por Escalar (k * A)\n\nA multiplicação por um escalar $k$ envolve a multiplicação de todos os elementos da matriz A pelo valor de $k$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 2\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4   -3    7\n[2,]   10    1    1\n[3,]   -5    2    3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiplicacao_escalar <- k * A\nmultiplicacao_escalar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    8   -6   14\n[2,]   20    2    2\n[3,]  -10    4    6\n```\n:::\n:::\n\n\n#### 3.2.3.5 Produto Elemento a Elemento (A * B)\n\nO produto elemento a elemento envolve a multiplicação dos elementos correspondentes nas matrizes A e B. As dimensões das matrizes devem ser **idênticas** para que essa operação seja válida.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4   -3    7\n[2,]   10    1    1\n[3,]   -5    2    3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2   -1    3\n[2,]    1    4    1\n[3,]    5   -2    7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nproduto_elemento_a_elemento <- A * B\nproduto_elemento_a_elemento\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    8    3   21\n[2,]   10    4    1\n[3,]  -25   -4   21\n```\n:::\n:::\n\n\n#### 3.2.3.6 Produto Matricial (A %*% B)\n\nO produto matricial é uma operação fundamental na álgebra linear. É obtido multiplicando as linhas da matriz A pelas colunas da matriz B e somando os resultados. As dimensões das matrizes devem ser compatíveis para essa operação.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproduto_matricial <- A %*% B\nproduto_matricial\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   40  -30   58\n[2,]   26   -8   38\n[3,]    7    7    8\n```\n:::\n:::\n\n\n#### 3.2.3.7 Transposta (`t(A)`)\n\nA transposta de uma matriz A é obtida **trocando suas linhas por colunas e vice-versa**. Ela é denotada por $t(A)$ e é usada em várias operações, como multiplicação matricial e decomposições.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4   -3    7\n[2,]   10    1    1\n[3,]   -5    2    3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntransposta_A <- t(A)\ntransposta_A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4   10   -5\n[2,]   -3    1    2\n[3,]    7    1    3\n```\n:::\n:::\n\n\n#### 3.2.3.8 Determinante (det(A))\n\nO determinante de uma matriz A é um valor escalar, e é utilizado para **resolver** sistemas de equações lineares, calcular inversas de matrizes e determinar propriedades de transformações geométricas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeterminante_A <- det(A)\ndeterminante_A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 284\n```\n:::\n:::\n\n\n#### 3.2.3.9 Inversa (`solve(A)`)\nA inversa de uma matriz A é uma matriz B tal que $A * B$ é a matriz identidade. Nem todas as matrizes têm inversa, e a função `solve()` calcula a inversa da matriz, quando possível.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninversa_A <- solve(A)\ninversa_A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             [,1]       [,2]        [,3]\n[1,]  0.003521127 0.08098592 -0.03521127\n[2,] -0.123239437 0.16549296  0.23239437\n[3,]  0.088028169 0.02464789  0.11971831\n```\n:::\n:::\n\n\n#### 3.2.3.10 Diagonal (`diag(A)`)\n\nA função `diag(A)` retorna os elementos da diagonal principal da matriz A.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4   -3    7\n[2,]   10    1    1\n[3,]   -5    2    3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndiagonal_A <- diag(A)\ndiagonal_A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 1 3\n```\n:::\n:::\n\n\n##### 3.2.3.11 Autovalores e Autovetores (`eigen(A)`)\nOs autovalores e autovetores de uma matriz A são fundamentais em álgebra linear e em várias aplicações. A função `eigen()` retorna uma lista contendo os autovalores e autovetores de A.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautovalores_autovetores_A <- eigen(A)\nautovalores_autovetores_A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neigen() decomposition\n$values\n[1] 1.851362+7.91586i 1.851362-7.91586i 4.297276+0.00000i\n\n$vectors\n                      [,1]                  [,2]         [,3]\n[1,] -0.0984470-0.5752367i -0.0984470+0.5752367i 0.2529012+0i\n[2,] -0.7184472+0.0000000i -0.7184472+0.0000000i 0.8853306+0i\n[3,]  0.3728112+0.0652405i  0.3728112-0.0652405i 0.3901676+0i\n```\n:::\n:::\n\n\n#### 3.2.3.12 Produto Matricial Transposto (`crossprod(A, B)`) e Produto Matricial de A e B Transposto (`tcrossprod(A, B)`)\n\nEssas funções realizam o produto matricial de A e B, considerando suas transpostas.\n\nO produto cruzado é também conhecido como “produto matricial interno” e é utilizado para diversos ajustes de modelos, análise multivariada, etc. Dada uma matriz A e uma matriz B, o produto interno entre elas é denotado como $A^T * B$, e é calculado pela função `crossprod(A, B)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproduto_transposto <- crossprod(A, B)\nproduto_transposto\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   -7   46  -13\n[2,]    5    3    6\n[3,]   30   -9   43\n```\n:::\n:::\n\n\nO produto matricial externo também é conhecido como “produto matricial externo transposto” e é utilizada na mesmas ocasiões do primeiro. Dada uma matriz A e uma matriz B, o produto externo transposto entre elas é denotado como $A * B^T$, e é calculado pela função `tcrossprod(A, B)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproduto_transposto_t <- tcrossprod(A, B)\nproduto_transposto_t\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   32   -1   75\n[2,]   22   15   55\n[3,]   -3    6   -8\n```\n:::\n:::\n\n\n#### 3.2.3.13 Nomes de Linhas e Colunas (rownames(A), colnames(A))\n\nAs funções `rownames()` e `colnames()` permitem atribuir nomes às linhas e colunas de uma matriz, facilitando a identificação de elementos em análises e visualizações.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(A) <- c(\"Linha1\", \"Linha2\", \"Linha3\")\ncolnames(A) <- c(\"Coluna1\", \"Coluna2\", \"Coluna3\")\n```\n:::\n\n\n#### 3.2.3.14 Matrizes Triangulares no R: Funções `upper.tri()` e `lower.tri()`\n\nMatrizes triangulares desempenham são úteis quando o objetivo é economizar espaço de armazenamento e realizar cálculos mais eficientes. No R, as funções `upper.tri()` e `lower.tri()` são usadas para identificar os elementos acima e abaixo da diagonal principal de uma matriz, respectivamente.\n\n##### 3.2.3.14.1 Identificando Elementos Acima da Diagonal Principal (upper.tri())\n\nA função `upper.tri()` retorna uma matriz de elementos lógicos que indica quais elementos de uma matriz estão acima da diagonal principal. Os elementos `TRUE` indicam que o elemento correspondente está acima da diagonal, enquanto os elementos `FALSE` indicam que o elemento está na diagonal ou abaixo dela.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(1:9, nrow = 3)\nupper_elements <- upper.tri(A)\nupper_elements\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]  [,2]  [,3]\n[1,] FALSE  TRUE  TRUE\n[2,] FALSE FALSE  TRUE\n[3,] FALSE FALSE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA[upper.tri(A)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 7 8\n```\n:::\n:::\n\n\n##### 3.2.3.14.2 Identificando Elementos Abaixo da Diagonal Principal (lower.tri())\n\nDa mesma forma, a função `lower.tri()` retorna uma matriz de elementos lógicos que indica quais elementos estão abaixo da diagonal principal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlower_elements <- lower.tri(A, diag = T)\nlower_elements\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]  [,2]  [,3]\n[1,] TRUE FALSE FALSE\n[2,] TRUE  TRUE FALSE\n[3,] TRUE  TRUE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA[lower.tri(A)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 6\n```\n:::\n:::\n\n\n## 3.3 Arrays\n\nArrays são estruturas **multidimensionais** úteis para armazenar e manipular dados em várias dimensões, são usados em diversas áreas, como processamento de imagens, simulações numéricas, análise de dados multidimensionais e modelagem estatística. Eles são essenciais para lidar com dados que possuem mais de duas dimensões, onde as matrizes não são suficientes para representar a complexidade dos dados. Eles podem ser criados usando a função `array()`, onde você especifica os elementos do array e suas dimensões.\n\n### 3.3.1 Criando Arrays\n\nPodemos criar um array usando a função `array()` da seguinte maneira:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Criando um array 2x3x4\narr <- array(1:24, dim = c(2, 3, 4))\narr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   13   15   17\n[2,]   14   16   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   19   21   23\n[2,]   20   22   24\n```\n:::\n:::\n\n\n\n### 3.3.2 Acessando Elementos\nOs elementos de um array são acessados usando índices que indicam a posição **em cada dimensão**. Por exemplo, para acessar o elemento na segunda linha, terceira coluna e quarta “profundidade” de um array arr, devemos fazer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelemento <- arr[2, 3, 4]\nelemento\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24\n```\n:::\n:::\n\n\nPara acessarmos todos os elementos da primeira camada podemos fazer o seguinte:\n\n\n::: {.cell}\n\n```{.r .cell-code}\narr[, , 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n:::\n\n\n\n### 3.3.3 Operações com Arrays\n\nAssim como com vetores e matrizes, você pode realizar várias operações com arrays:\n\n* **Soma e Subtração**: Arrays podem ser somados e subtraídos elemento a elemento, desde que tenham as mesmas dimensões.\n\n* **Multiplicação por Escalar**: Você pode multiplicar um array por um escalar, o que multiplicará cada elemento do array pelo escalar.\n\n* **Produto Elemento a Elemento**: Dois arrays com as mesmas dimensões podem ser multiplicados elemento a elemento.\n\n* **Operações Estatísticas**: Funções como `sum()`, `mean()`, `max()`, `min()` podem ser aplicadas aos elementos do array, opcionalmente especificando a dimensão ao longo da qual a operação deve ser realizada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Criando dois arrays\narr1 <- array(1:12, dim = c(3, 2, 2))\narr2 <- array(13:24, dim = c(3, 2, 2))\n\n# Soma de arrays\nsoma <- arr1 + arr2\n\n# Produto element-wise\nproduto <- arr1 * arr2\n\n# Média ao longo da terceira dimensão\nmedia <- mean(arr1, dim = 3)\n```\n:::\n\n\n\n## 3.4 Listas\n\nEm programação, muitas vezes nos deparamos com a necessidade de armazenar diferentes tipos de dados em uma única estrutura. As listas em R são uma solução flexível para essa situação. Ao contrário de vetores e matrizes , onde os elementos devem ser do mesmo tipo, as listas permitem que você combine elementos de tipos diferentes em uma única estrutura. Essa versatilidade torna as listas uma escolha valiosa para armazenar dados complexos e heterogêneos.\n\n### 3.4.1 Criando Listas\n\nA criação de uma lista em R é simples e flexível. Você pode usar a função `list()` para criar uma lista vazia e, em seguida, atribuir elementos a ela.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Criando uma lista com diferentes tipos de elementos\nminha_lista <- list(\n  nome = \"Alice\",\n  idade = 15,\n  notas = c(90, 85, 95),\n  ativo = TRUE, \n  País = \"das Maravilhas\", \n  amigos = \"Cheshire\", \n  frase = \"How do I know I'm mad?\"\n)\nminha_lista\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nome\n[1] \"Alice\"\n\n$idade\n[1] 15\n\n$notas\n[1] 90 85 95\n\n$ativo\n[1] TRUE\n\n$País\n[1] \"das Maravilhas\"\n\n$amigos\n[1] \"Cheshire\"\n\n$frase\n[1] \"How do I know I'm mad?\"\n```\n:::\n:::\n\n\n\n### 3.4.2 Acessando Elementos da Lista\n\nVocê pode acessar os elementos de uma lista usando o operador de índice `[[]]` ou o operador `$` (quando estamos em uma lista nomeada). O operador `[[]]` é usado quando você deseja acessar um elemento específico pelo seu nome.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Acessando elementos da lista\nnome <- minha_lista$nome\nnome\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alice\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nidade <- minha_lista[[\"idade\"]]\nidade\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnotas <- minha_lista$notas\nnotas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 90 85 95\n```\n:::\n:::\n\n\n### 3.4.3 Manipulando Listas\n\nAs listas oferecem muitas possibilidades de manipulação. Você pode adicionar, remover e modificar elementos, bem como alterar seus nomes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Adicionando um novo elemento à lista\nminha_lista$cidade <- \"São Paulo\"\nminha_lista$cidade\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"São Paulo\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Modificando um elemento existente\nminha_lista$idade <- 31\nminha_lista\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nome\n[1] \"Alice\"\n\n$idade\n[1] 31\n\n$notas\n[1] 90 85 95\n\n$ativo\n[1] TRUE\n\n$País\n[1] \"das Maravilhas\"\n\n$amigos\n[1] \"Cheshire\"\n\n$frase\n[1] \"How do I know I'm mad?\"\n\n$cidade\n[1] \"São Paulo\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Removendo um elemento da lista\nminha_lista$notas <- NULL\nminha_lista\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nome\n[1] \"Alice\"\n\n$idade\n[1] 31\n\n$ativo\n[1] TRUE\n\n$País\n[1] \"das Maravilhas\"\n\n$amigos\n[1] \"Cheshire\"\n\n$frase\n[1] \"How do I know I'm mad?\"\n\n$cidade\n[1] \"São Paulo\"\n```\n:::\n:::\n\n\n### 3.4.4 Aninhamento de Listas\nUma característica poderosa das listas é a capacidade de aninhar outras listas dentro delas. Isso permite que você crie estruturas de dados hierárquicas e organizadas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Aninhando listas\nendereco <- list(\n  rua = \"Rua Principal\",\n  numero = 123,\n  cidade = \"São Paulo\"\n)\n\nminha_lista$endereco <- endereco\nminha_lista\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nome\n[1] \"Alice\"\n\n$idade\n[1] 31\n\n$ativo\n[1] TRUE\n\n$País\n[1] \"das Maravilhas\"\n\n$amigos\n[1] \"Cheshire\"\n\n$frase\n[1] \"How do I know I'm mad?\"\n\n$cidade\n[1] \"São Paulo\"\n\n$endereco\n$endereco$rua\n[1] \"Rua Principal\"\n\n$endereco$numero\n[1] 123\n\n$endereco$cidade\n[1] \"São Paulo\"\n```\n:::\n:::\n\n\n\n## 3.5 Data Frames em R\n\nData Frames são estruturas de **dados bidimensionais** em R, semelhantes a tabelas, que podem armazenar **diferentes tipos de dados** em suas colunas. Eles são amplamente utilizados para análise e manipulação de dados.\n\n### 3.5.1 Criação de Data Frames\n\nPara criar um Data Frame em R, podemos utilizar a função `data.frame()`. Cada argumento da função representa uma coluna do Data Frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemplo de criação de Data Frame\nmeu_data_frame <- data.frame(\n  nome = c(\"Alice\", \"Bob\", \"Carol\", \"Ana\", \"João\", \"Carlos\", \"Patrícia\", \"Leonardo\"),\n  idade = c(25, 30, 28, 20, 27, 50, 60, 45),\n  salario = c(5000, 6000, 5500, 8000, 2000, 3500, 10000, 3800 ), \n  meio_de_transporte = c('onibus', 'bicicleta', 'onibus', 'carro', 'carro', 'onibus', 'onibus', 'bicicleta')\n)\n\n## Nomes de colunas do nosso data.frame não possuem espaço, podem ser separadas por \".\" ou \"_\".\n```\n:::\n\n\n### 3.5.2 Adcionando variáveis (colunas)\n\nPara adcionar novas colunas em um data.frame podemos simplesmente atribuir seus valores através do seguinte código:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_data_frame$genero <- c(\"F\", \"M\", \"F\", \"F\", \"M\", \"M\", \"F\", \"M\")\n```\n:::\n\n\n### 3.5.3 Acessando Colunas\n\nVocê pode acessar as colunas de um data.frame usando o operador `$` ou colchetes `[]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Acessar coluna usando o operador $\nmeu_data_frame$nome\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alice\"    \"Bob\"      \"Carol\"    \"Ana\"      \"João\"     \"Carlos\"   \"Patrícia\"\n[8] \"Leonardo\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Acessar coluna usando colchetes []\nmeu_data_frame[, \"idade\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25 30 28 20 27 50 60 45\n```\n:::\n:::\n\n\n### 3.5.4 Subconjuntos de Data Frames\nPara criar subconjuntos de Data Frames, você pode usar a função `subset()` ou colchetes `[]` com condições lógicas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubconjunto_df <- meu_data_frame[meu_data_frame$idade > 28, ]  # Seleciona pessoas com idade maior que 28\nsubconjunto_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      nome idade salario meio_de_transporte genero\n2      Bob    30    6000          bicicleta      M\n6   Carlos    50    3500             onibus      M\n7 Patrícia    60   10000             onibus      F\n8 Leonardo    45    3800          bicicleta      M\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Usando a função subset()\nsubconjunto_df <- subset(meu_data_frame, idade > 28)\nsubconjunto_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      nome idade salario meio_de_transporte genero\n2      Bob    30    6000          bicicleta      M\n6   Carlos    50    3500             onibus      M\n7 Patrícia    60   10000             onibus      F\n8 Leonardo    45    3800          bicicleta      M\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsubconjunto_combinado <- meu_data_frame[meu_data_frame$idade > 25 & meu_data_frame$idade < 30, ]\nsubconjunto_combinado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   nome idade salario meio_de_transporte genero\n3 Carol    28    5500             onibus      F\n5  João    27    2000              carro      M\n```\n:::\n:::\n\n\n\nPodemos acessar a classe individualmente de uma coluna do nosso data.frame utilizando `class()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(meu_data_frame$nome)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(meu_data_frame$idade)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nPodemos acessar a estrutura dos nossos dados utilizando a função `str()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(meu_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t8 obs. of  5 variables:\n $ nome              : chr  \"Alice\" \"Bob\" \"Carol\" \"Ana\" ...\n $ idade             : num  25 30 28 20 27 50 60 45\n $ salario           : num  5000 6000 5500 8000 2000 3500 10000 3800\n $ meio_de_transporte: chr  \"onibus\" \"bicicleta\" \"onibus\" \"carro\" ...\n $ genero            : chr  \"F\" \"M\" \"F\" \"F\" ...\n```\n:::\n:::\n\n\n\nAs dimensões de um data.frame podem ser dadas por `dim()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(meu_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8 5\n```\n:::\n:::\n\n\n\nPara sabermos o número de observações em um data.frame podemos utilizar a função `nrow()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(meu_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\nPara obtermos o número de colunas em um data.frame podemos utilizar a função `ncol()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncol(meu_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n### 3.5.5 Função `summary()`\nA função `summary()` é usada para obter um *resumo estatístico* das variáveis em um Data Frame. Ela fornece estatísticas como média, mediana, mínimo, máximo e quartis para cada coluna numérica.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(meu_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     nome               idade          salario      meio_de_transporte\n Length:8           Min.   :20.00   Min.   : 2000   Length:8          \n Class :character   1st Qu.:26.50   1st Qu.: 3725   Class :character  \n Mode  :character   Median :29.00   Median : 5250   Mode  :character  \n                    Mean   :35.62   Mean   : 5475                     \n                    3rd Qu.:46.25   3rd Qu.: 6500                     \n                    Max.   :60.00   Max.   :10000                     \n    genero         \n Length:8          \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n```\n:::\n:::\n\n\n### 3.5.6 Função `by()`\nA função `by()` é usada para aplicar uma função a subconjuntos de um Data Frame, com base em uma ou mais variáveis. Ela é útil para realizar operações em *grupos de dados*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemplo de uso da função by()\nresultado <- by(meu_data_frame$salario, meu_data_frame$idade, mean)\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmeu_data_frame$idade: 20\n[1] 8000\n------------------------------------------------------------ \nmeu_data_frame$idade: 25\n[1] 5000\n------------------------------------------------------------ \nmeu_data_frame$idade: 27\n[1] 2000\n------------------------------------------------------------ \nmeu_data_frame$idade: 28\n[1] 5500\n------------------------------------------------------------ \nmeu_data_frame$idade: 30\n[1] 6000\n------------------------------------------------------------ \nmeu_data_frame$idade: 45\n[1] 3800\n------------------------------------------------------------ \nmeu_data_frame$idade: 50\n[1] 3500\n------------------------------------------------------------ \nmeu_data_frame$idade: 60\n[1] 10000\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- by(meu_data_frame$salario, meu_data_frame$genero, median)\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmeu_data_frame$genero: F\n[1] 6750\n------------------------------------------------------------ \nmeu_data_frame$genero: M\n[1] 3650\n```\n:::\n:::\n\n\n### 3.5.7 Funções para Explorar Data Frames\n* `**head()**`: Mostra as primeiras linhas do Data Frame.\n* `**tail()**`: Mostra as últimas linhas do Data Frame.\n* `**summary()**`: Fornece um resumo estatístico das colunas numéricas.\n* `**str()**`: Mostra a estrutura do Data Frame, incluindo tipos de dados.\n\n### 3.5.8 Manipulação de Data Frames\n\n* Adição de colunas: `meu_data_frame$nova_coluna <- valores`\n* Remoção de colunas: `meu_data_frame$coluna_a_ser_removida <- NULL`\n* Filtragem de linhas: subconjunto <- `meu_data_frame[meu_data_frame$idade > 25, ]`\n* Ordenação: ordenado <- `meu_data_frame[order(meu_data_frame$idade), ]`\n\n## 3.6 Fatores\n\nFatores são uma estrutura de dados especial em R usada para representar **variáveis categóricas**, ou seja, variáveis que assumem um conjunto limitado e definido de valores. Os fatores são especialmente úteis para armazenar informações categóricas de maneira eficiente e para realizar análises estatísticas em dados categóricos.\n\n### 3.6.1 Criação de Fatores\n\nVocê pode criar um fator em R usando a função `factor()`. É necessário fornecer um vetor de valores categóricos e, opcionalmente, os níveis que esses valores podem assumir.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemplo de criação de fator\ngenero <- factor(c(\"Masculino\", \"Feminino\", \"Masculino\", \"Feminino\"))\n```\n:::\n\n\n### 3.6.2 Transformação em fatores\n\nMuitas vezes podemos estar interessados em transformar uma variável em um fator, para isso, utilizamos a função `as.factor`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_data_frame$genero\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"F\" \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"M\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_data_frame$genero = as.factor(meu_data_frame$genero)\n\nmeu_data_frame$genero\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] F M F F M M F M\nLevels: F M\n```\n:::\n:::\n\n\n### 3.6.3 Níveis de Fatores\n\nOs níveis de um fator são os valores únicos que a variável categórica pode assumir. Se você não fornecer os níveis explicitamente, o R inferirá os níveis a partir dos valores presentes. Além disso, os níveis serão ordenados em ordem alfanumérica, caso omitidos. É importante passarmos os níveis (*levels*) quando lidamos com variáveis ordinais.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definindo fator com níveis específicos\ncores <- factor(c(\"Vermelho\", \"Verde\", \"Azul\"), levels = c(\"Vermelho\", \"Verde\", \"Azul\", \"Amarelo\"))\ncores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Vermelho Verde    Azul    \nLevels: Vermelho Verde Azul Amarelo\n```\n:::\n:::\n\n\n### 3.6.4 Acessando Níveis e Valores de Fatores\n\nVocê pode acessar os níveis de um fator usando a função `levels()` e os valores do fator como um vetor usando o fator diretamente. Para sabermos a quantidade de níveis de um fator podemos utilizar a função `nlevels()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Acessar níveis de um fator\nniveis_cores <- levels(cores)\nniveis_cores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Vermelho\" \"Verde\"    \"Azul\"     \"Amarelo\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Acessar o número de níveis de um fator\nn_niveis_cores <- nlevels(cores)\nn_niveis_cores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Acessar valores do fator\nvalores_cores <- cores\nvalores_cores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Vermelho Verde    Azul    \nLevels: Vermelho Verde Azul Amarelo\n```\n:::\n:::\n\n\n## 3.7 Tabelas de Dupla Entrada\n\nTabelas de dupla entrada, também conhecidas como tabelas de contingência, util para analisar a relação entre duas variáveis categóricas. Elas mostram a frequência ou contagem de ocorrências conjuntas dessas variáveis e são frequentemente usadas para entender associações e padrões nos dados.\n\n### 3.7.1 Criando Tabelas de Dupla Entrada\nPara criar uma tabela de dupla entrada em R, você pode usar a função `table()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemplo de criação de tabela de dupla entrada\nsexo <- c(\"Masculino\", \"Feminino\", \"Masculino\", \"Masculino\", \"Feminino\")\ncidade <- c(\"A\", \"B\", \"A\", \"B\", \"A\")\ntabela_contingencia <- table(sexo, cidade)\ntabela_contingencia\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           cidade\nsexo        A B\n  Feminino  1 1\n  Masculino 2 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntabela_contingencia2 <- table(meu_data_frame$meio_de_transporte, meu_data_frame$genero)\ntabela_contingencia2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           \n            F M\n  bicicleta 0 2\n  carro     1 1\n  onibus    3 1\n```\n:::\n:::\n\n\n* **Visualizando Tabelas de Dupla Entrada:**\n\nVocê pode visualizar a tabela de dupla entrada diretamente ou usar a função `ftable()` para obter uma exibição mais formatada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualizar tabela de dupla entrada\nprint(tabela_contingencia)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           cidade\nsexo        A B\n  Feminino  1 1\n  Masculino 2 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exibição formatada da tabela\ntabela_formatada <- ftable(tabela_contingencia)\nprint(tabela_formatada)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          cidade A B\nsexo                \nFeminino         1 1\nMasculino        2 1\n```\n:::\n:::\n\n\n### 3.7.2 Analisando Tabelas de Dupla Entrada\nVocê pode usar várias funções para analisar e obter informações úteis a partir de tabelas de dupla entrada.\n\n* **Marginais**: Obtém as marginais (somas das linhas e colunas) da tabela.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarginais_linhas <- margin.table(tabela_contingencia, 1)  # Somas das linhas\nmarginais_colunas <- margin.table(tabela_contingencia, 2)  # Somas das colunas\n```\n:::\n\n\n* **Teste Qui-Quadrado**: `chisq.test()` realiza o teste qui-quadrado para avaliar a independência das variáveis.\n\n::: {.cell}\n\n```{.r .cell-code}\nqui_quadrado <- chisq.test(tabela_contingencia)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in chisq.test(tabela_contingencia): Aproximação do qui-quadrado pode\nestar incorreta\n```\n:::\n:::\n\n\nWarning in chisq.test(tabela_contingencia): Chi-squared approximation may be\nincorrect\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(qui_quadrado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tPearson's Chi-squared test with Yates' continuity correction\n\ndata:  tabela_contingencia\nX-squared = 0, df = 1, p-value = 1\n```\n:::\n:::\n\n\n* **Proporções Relativas**: `prop.table()` calcula proporções relativas dentro das categorias.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproporcoes_relativas_linha <- prop.table(tabela_contingencia, margin = 1)  # Proporções por linha\nproporcoes_relativas_linha\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           cidade\nsexo                A         B\n  Feminino  0.5000000 0.5000000\n  Masculino 0.6666667 0.3333333\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nproporcoes_relativas_coluna <- prop.table(tabela_contingencia, margin = 2)  # Proporções por linha\nproporcoes_relativas_coluna\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           cidade\nsexo                A         B\n  Feminino  0.3333333 0.5000000\n  Masculino 0.6666667 0.5000000\n```\n:::\n:::\n\n\n### 3.7.3 Lendo dados disponíveis no R\nPara vermos os banco de dados disponíveis no R podemos utilizar a função `data()`, e para ler um deles basta chamar seu nome como argumento da função, por exemplo: `data(USArrests)`.\n\n## 3.8 Exercício\n**Para os dados de `USArrests` faça o que se pede**.\n\n1. Imprima na tela as 9 primeiras observações.\n2. Imprima as últimas 3 observações.\n3. Quantas observações temos?\n4. Quantas variáveis temos?\n5. Apresente o sumário dos dados.\n6. Apresente a estrutura dos dados.\n7. Indique os estados cujo número de `Murder` está entre 10 e 15.\n8. Qual a média de `Assault` para os estados cuja variável `Rape` está no IQR ($Q3 - Q1$)?\n\n## 3.9 Estruturas alternativas ao Data Frame\n\nEmbora data.frames sejam estruturas muito poderosas para análise de dados, outras estruturas são mais modernas e permitem maior performance para análise de dados em termos de velocidade de processamento e até mesmo na facilidade da sintaxe. Duas alternativas são: `data.table` e `tibble`. Veremos as duas em detalhes a seguir.\n\n### 3.9.1 `data.table`: Manipulação Eficiente de Grandes Conjuntos de Dados\n\nO pacote `data.table` é uma biblioteca poderosa no R, projetada especificamente para manipulação eficiente de **grandes conjuntos de dados**. Ele oferece um conjunto de recursos que melhoram consideravelmente o desempenho e a flexibilidade das operações em relação às estruturas de dados convencionais.\n\n#### 3.9.1.1 Principais Características do `data.table`\n\n1. **Sintaxe Otimizada**: Uma das características principais do “data.table” é sua sintaxe otimizada. A operação básica do “data.table” usa a notação `[i, j, by]`, onde `i` filtra linhas, `j` seleciona colunas e `by` agrupa resultados. Isso permite que você realize várias operações complexas em uma única linha de código.\n\n2. **Eficiência em Memória**: O “data.table” realiza muitas operações diretamente na memória, evitando a cópia excessiva de dados, minimizando o consumo de memória e melhorando o desempenho.\n\n3. **Chaves e Indexação**: As chaves são um conceito fundamental no “data.table”. Elas permitem que você especifique quais colunas serão usadas para ordenar e indexar o conjunto de dados. Isso acelera significativamente operações de junção e seleção.\n\n4. **Compatibilidade com Sintaxe de Base R**: Embora tenha sua própria sintaxe otimizada, o “data.table” também é compatível com a sintaxe de base R, o que facilita a transição para os usuários familiarizados com o R padrão.\n\n#### 3.9.1.2 Criando e Manipulando Data.Tables\nPara criar um “data.table”, você pode usar a função `data.table()`. Vamos explorar exemplos mais detalhados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n\n# Criar um data.table\nmeu_data_table <- data.table(\n  nome = c(\"Alice\", \"Bob\", \"Carol\", \"Ana\", \"João\", \"Carlos\", \"Patrícia\", \"Leonardo\"),\n  idade = c(25, 30, 28, 20, 27, 50, 60, 45),\n  salario = c(5000, 6000, 5500, 8000, 2000, 3500, 10000, 3800 ), \n  meio_de_transporte = c('onibus', 'bicicleta', 'onibus', 'carro', 'carro', 'onibus', 'onibus', 'bicicleta'))\nmeu_data_table\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       nome idade salario meio_de_transporte\n1:    Alice    25    5000             onibus\n2:      Bob    30    6000          bicicleta\n3:    Carol    28    5500             onibus\n4:      Ana    20    8000              carro\n5:     João    27    2000              carro\n6:   Carlos    50    3500             onibus\n7: Patrícia    60   10000             onibus\n8: Leonardo    45    3800          bicicleta\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(meu_data_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.table\" \"data.frame\"\n```\n:::\n:::\n\n\nPara importarmos um data.table podemos utilizar a função `fread()`, epara salvarmos, podemos utilizar a função `fwrite()`.\n\n#### 3.9.1.3 Sintaxe e Operações\n\nA sintaxe básica do “data.table” envolve o uso das notações `[i, j, by]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecionar colunas e filtrar linhas\nresultado <- meu_data_table[idade > 25, .(nome, salario)]\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       nome salario\n1:      Bob    6000\n2:    Carol    5500\n3:     João    2000\n4:   Carlos    3500\n5: Patrícia   10000\n6: Leonardo    3800\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Agregar dados \nagregado <- meu_data_table[, .(media_salario = mean(salario)),]\nagregado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   media_salario\n1:          5475\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Agregar dados por idade\nagregado_idade <- meu_data_table[, .(media_salario = mean(salario)), by = idade]\nagregado_idade\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   idade media_salario\n1:    25          5000\n2:    30          6000\n3:    28          5500\n4:    20          8000\n5:    27          2000\n6:    50          3500\n7:    60         10000\n8:    45          3800\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Agregar dados por meio_de_transporte\nagregado_mt <- meu_data_table[, .(media_salario = mean(salario)), by = meio_de_transporte]\nagregado_mt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   meio_de_transporte media_salario\n1:             onibus          6000\n2:          bicicleta          4900\n3:              carro          5000\n```\n:::\n:::\n\n\n### 3.9.2 Tibble: Uma Abordagem Moderna para Manipulação de Dados\n\nNo ambiente estatístico e analítico do R, a manipulação e análise de dados são atividades cruciais. O pacote “tibble” oferece uma abordagem moderna e conveniente para trabalhar com conjuntos de dados, aprimorando muitos dos aspectos do tradicional “data.frame”. O tibble faz parte do tidyverse, e foi projetado para atender às necessidades de análise de dados eficiente, mantendo a coerência dos tipos de dados e melhorando a experiência geral do usuário.\n\n#### 3.9.2.1 Principais Características do Tibble\n\n1. **Sintaxe Intuitiva para Criação**: A criação de um “tibble” é similar ao data.frame e data.table, oferecendo uma sintaxe intuitiva e direta. Você pode criar um “tibble” usando a função `tibble()` e atribuir colunas com nomes claros. Em Tibble você pode utilizar espaços para nomear variáveis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(tibble)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: tibble\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(magrittr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: magrittr\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: dplyr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:data.table':\n\n    between, first, last\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_tibble <- tibble(\n  nome = c(\"Alice\", \"Bob\", \"Carol\", \"Ana\", \"João\", \"Carlos\", \"Patrícia\", \"Leonardo\"),\n  idade = c(25, 30, 28, 20, 27, 50, 60, 45),\n  salario = c(5000, 6000, 5500, 8000, 2000, 3500, 10000, 3800 ), \n  meio_de_transporte = c('onibus', 'bicicleta', 'onibus', 'carro', 'carro', 'onibus', 'onibus', 'bicicleta'))\nmeu_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 4\n  nome     idade salario meio_de_transporte\n  <chr>    <dbl>   <dbl> <chr>             \n1 Alice       25    5000 onibus            \n2 Bob         30    6000 bicicleta         \n3 Carol       28    5500 onibus            \n4 Ana         20    8000 carro             \n5 João        27    2000 carro             \n6 Carlos      50    3500 onibus            \n7 Patrícia    60   10000 onibus            \n8 Leonardo    45    3800 bicicleta         \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(meu_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 8\nColumns: 4\n$ nome               <chr> \"Alice\", \"Bob\", \"Carol\", \"Ana\", \"João\", \"Carlos\", \"…\n$ idade              <dbl> 25, 30, 28, 20, 27, 50, 60, 45\n$ salario            <dbl> 5000, 6000, 5500, 8000, 2000, 3500, 10000, 3800\n$ meio_de_transporte <chr> \"onibus\", \"bicicleta\", \"onibus\", \"carro\", \"carro\", …\n```\n:::\n:::\n\n       \n2. **Manipulação de Colunas**: A adição, renomeação e remoção de colunas são tarefas simples com o “tibble”. Você pode usar o operador `$` para acessar as colunas e o operador `%>%` para encadear operações.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_tibble$nova_coluna <- c(1, 2, 3, 4, 5, 6, 7, 8)\nmeu_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 5\n  nome     idade salario meio_de_transporte nova_coluna\n  <chr>    <dbl>   <dbl> <chr>                    <dbl>\n1 Alice       25    5000 onibus                       1\n2 Bob         30    6000 bicicleta                    2\n3 Carol       28    5500 onibus                       3\n4 Ana         20    8000 carro                        4\n5 João        27    2000 carro                        5\n6 Carlos      50    3500 onibus                       6\n7 Patrícia    60   10000 onibus                       7\n8 Leonardo    45    3800 bicicleta                    8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_tibble <- mutate(meu_tibble, `minha coluna` = 1:8)\n\nmeu_tibble <-  rename(meu_tibble, idade_anos = idade)\nmeu_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 6\n  nome     idade_anos salario meio_de_transporte nova_coluna `minha coluna`\n  <chr>         <dbl>   <dbl> <chr>                    <dbl>          <int>\n1 Alice            25    5000 onibus                       1              1\n2 Bob              30    6000 bicicleta                    2              2\n3 Carol            28    5500 onibus                       3              3\n4 Ana              20    8000 carro                        4              4\n5 João             27    2000 carro                        5              5\n6 Carlos           50    3500 onibus                       6              6\n7 Patrícia         60   10000 onibus                       7              7\n8 Leonardo         45    3800 bicicleta                    8              8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_tibble_sem_salario <- select(meu_tibble, -salario)\nmeu_tibble_sem_salario\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 5\n  nome     idade_anos meio_de_transporte nova_coluna `minha coluna`\n  <chr>         <dbl> <chr>                    <dbl>          <int>\n1 Alice            25 onibus                       1              1\n2 Bob              30 bicicleta                    2              2\n3 Carol            28 onibus                       3              3\n4 Ana              20 carro                        4              4\n5 João             27 carro                        5              5\n6 Carlos           50 onibus                       6              6\n7 Patrícia         60 onibus                       7              7\n8 Leonardo         45 bicicleta                    8              8\n```\n:::\n:::\n\n\n\n#### 3.9.2.2 Operações e Uso do Tibble\nO “tibble” se integra perfeitamente com as operações do tidyverse, tornando a manipulação de dados mais eficaz e legível. Podemos usar operações como filtragem, ordenação e agregação de forma simples e concisa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filtrar e ordenar\nresultado <- filter(meu_tibble, idade_anos > 25) \narrange(resultado, desc(salario))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  nome     idade_anos salario meio_de_transporte nova_coluna `minha coluna`\n  <chr>         <dbl>   <dbl> <chr>                    <dbl>          <int>\n1 Patrícia         60   10000 onibus                       7              7\n2 Bob              30    6000 bicicleta                    2              2\n3 Carol            28    5500 onibus                       3              3\n4 Leonardo         45    3800 bicicleta                    8              8\n5 Carlos           50    3500 onibus                       6              6\n6 João             27    2000 carro                        5              5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Agregar por idade e calcular média de salários\nagregado_por_idade <-  group_by(meu_tibble, idade_anos) \n\nsummarize(agregado_por_idade, media_salario = mean(salario))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 2\n  idade_anos media_salario\n       <dbl>         <dbl>\n1         20          8000\n2         25          5000\n3         27          2000\n4         28          5500\n5         30          6000\n6         45          3800\n7         50          3500\n8         60         10000\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}