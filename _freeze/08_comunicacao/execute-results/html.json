{
  "hash": "1ef18fcbd19082c13856513443779ff8",
  "result": {
    "markdown": "---\nalways_allow_html: true\ntitle: \"8  Comunicação\"\n---\n\n\n## 8.1 Relatórios dinâmicos\n\nRelatórios dinâmicos são uma ferramenta essencial para analisar dados e compartilhar resultados. Focaremos aqui em Quarto.\n\n### 8.1.1 Quarto\n\nO [Quarto](https://quarto.org/) permite a criação e publicação de artigos, apresentações, relatórios, websites, blogs, livros etc em diversos formatos como HTML, PDF, Word, ePub. O Quarto permite que o usuário personalize completamente o documento a ser gerado e pode ser utilizado a partir do RStudio, VSCode, Jupyter etc. Além de incorporar Markdown com diversas linguagens de programação (como R, Python, C, Julia etc ).\n\nTodo documento em Quarto ou RMarkdown começam com um **YAML** (“YAML Ain’t Markup Language”) .\n\n#### 8.1.1.1 YAML header\n\nO YAML é usado para representar estruturas de dados, como listas, dicionários, valores escalares e aninhamentos de dados de forma legível e intuitiva.\n\nAqui estão algumas características e conceitos-chave do YAML:\n\n1. **Sintaxe Clara**: O YAML usa uma sintaxe simples baseada em espaços e indentação para estruturar os dados, tornando essa estrutura legíveis.\n\n2. **Pares de Chave e Valor**: O YAML é frequentemente usado para representar dados como pares de chave e valor, onde a chave é seguida de dois pontos (`:`) e o valor é especificado após a chave.\n\n## 8.2 Criando Relatórios\n\nVamos começar com um exemplo simples de YAML.\n\n* Em um caso simples, temos apenas no nome do autor, nome do documento e a data.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\n---\n```\n:::\n\n\n* Contudo, normalmente, temos interesse em incluir mais informações no nosso documento, ou até mesmo personalizarmos o nosso documento. Vamos ver agora, como incluir informações como subtítulo, formato de data e alterar a linguagem do documento.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long # date-format: dddd MMM D, YYYY   \nlang: pt\n---\n```\n:::\n\n\n* **Escolha do formato**: O arquivo gerado pode ser em diferentes formatos, e podemos gerar relatórios em diversos formatos simultaneamente.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long # date-format: dddd MMM D, YYYY   \nlang: pt\nformat: \n   html: default\n   pdf: default\n   docx: default\n---\n```\n:::\n\n\n* **Alterando o tema do código**: Podemos personalizar cada arquivo de maneira diferente. Vamos alterar a formatação do código de maneira diferente em cada arquivo.\n  \n  * [Mais temas para o código.](https://quarto.org/docs/output-formats/html-code.html#highlighting)\n  \n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long # date-format: dddd MMM D, YYYY   \nlang: pt\n\nformat: \n  pdf: \n    highlight-style: dracula\n  html:\n    highlight-style: solarized\n  docx: default\n---\n```\n:::\n\n\n* **Alterando o tema**: Muitas vezes, temos interesse em alterar o tema do nosso documento (e não apenas do código). Vamos focar agora nas alterações do html.\n\n  * [Mais temas para o relatório HTML](https://quarto.org/docs/output-formats/html-themes.html)\n  \n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long # date-format: dddd MMM D, YYYY   \nlang: pt\ntheme: \n  light: yeti\n  dark: slate\nformat: \n  pdf: \n    highlight-style: dracula\n  html:\n    highlight-style: solarized\n  docx: default\n---\n```\n:::\n\n  \n* **Formatação dos códigos**: O código pode ser formatado quanto a sua estética no relatório.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long # date-format: dddd MMM D, YYYY   \nlang: pt\ntitle-block-style: none\ntheme: \n  light: yeti\n  dark: slate\n  \nformat: \n  html:\n    code-fold: true\n    code-summary: \"R\"\n    code-overflow: scroll\n    code-tools: true\n    code-line-numbers: false\n    highlight-style: dracula\n    code-link: true ## Funciona se o code-line é false\n---\n```\n:::\n\n\n* **Formatando cores e tamanho do texto e dos links**: O texto pode ser formatado quanto a seu tamanho e cor diretamente no YAML, porém, sua alteração afeta na seleção do tema.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long \nlang: pt\ntitle-block-style: none\n\nformat: \n  html:\n    code-fold: true\n    code-summary: \"R\"\n    code-overflow: scroll\n    code-link: true\n    code-tools: true\n    code-line-numbers: true\n    fontcolor: '#C25E8C'\n    linkcolor: '#00C9BA'\n    fontsize: 1.1em\n    highlight-style: dracula\n---\n```\n:::\n\n\n* **Formatação de figuras**: Figuras podem ter suas dimensões e alinhamentos ajustadas em cada chunck, ou no YAML.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long \nlang: pt\ntitle-block-style: none\n\nfig-align: center\nfig-width: 10\nfig-height: 12\n\nformat: \n  html:\n    code-fold: true\n    code-summary: \"R\"\n    code-overflow: scroll\n    code-link: true\n    code-tools: true\n    code-line-numbers: true\n    theme:\n     light: flatly\n     dark: darkly\n    fontsize: 1.1em\n    highlight-style: dracula\n---\n```\n:::\n\n\n* **Incluindo sumário (tabela de conteúdo)**: Podemos incluir um sumário, personalizar seu título e sua profundidade.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long \nlang: pt\ntitle-block-style: none\n\nfig-align: center\nfig-width: 10\nfig-height: 12\n\ntoc: true\ntoc-depth: 5\ntoc-title: \"Agenda\"\n\nformat: \n  html:\n    code-fold: true\n    code-summary: \"R\"\n    code-overflow: scroll\n    code-link: true\n    code-tools: true\n    code-line-numbers: false\n    theme:\n     light: flatly\n     dark: darkly\n    fontsize: 1.1em\n    highlight-style: dracula\n---\n```\n:::\n\n\n* **Incluíndo Referências**: Para incluimos referências devemos criar um arquivo `.bib` e salvar as informações sobre a nossa referência.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n@book{wickham2016,\n    title = {R for Data Science: Import, Tidy, Transform, Visualize, and Model Data},\n    author = {Wickham, H. and Grolemund, G.},\n    year = {2016},\n    date = {2016},\n    publisher = {O'Reilly Media},\n    note = {LCCN: 2017300238}\n}\n```\n:::\n\n\n* **Adicionando citações**: Para citarmos a referência basta utilizar a seguinte sintaxe `[@wickham2016]`, que ela ficará assim ([Wickham e Grolemund 2016]@book).\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long \nlang: pt\n\nfig-align: center\nfig-width: 10\nfig-height: 12\n\ntoc: true\ntoc-depth: 3\ntoc-title: \"Agenda\"\n\nbibliography: references.bib\n\nformat: \n  html:\n    code-fold: true\n    code-summary: \"R\"\n    code-overflow: scroll\n    code-link: true\n    code-tools: true\n    code-line-numbers: true\n    citations-hover: true\n    citation-location: margin\n    theme:\n     light: flatly\n     dark: darkly\n    fontsize: 1.1em\n    highlight-style: dracula\n---\n```\n:::\n\n\n* **Relatórios com alteração de parâmetros**: Muitas vezes, precisamos rodar relatórios similares, porém, com alguns parâmetros diferentes. Para isso, podemos incluir no YAML o seguinte:\n\n\n::: {.cell}\n\n```{.latex .cell-code}\nparams:\n  alpha: 0.1\n  ratio: 0.1\n```\n:::\n\n\nPara acessarmos esses parâmetros no R, utilizamos:\n\n\n::: {.cell}\n\n```{.latex .cell-code}\nparams$alpha\n```\n:::\n\n\n## 8.3 Criando Apresentações\n\nAlém do suporte para relatórios, o quarto apresenta suporte para apresentações. Para isso, podemos utilizar o formato `revealjs`.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long \nlang: pt\n\nfig-align: center\nfig-width: 10\nfig-height: 12\n\ntoc: true\ntoc-depth: 3\ntoc-title: \"Agenda\"\n\nbibliography: references.bib\n\nformat: revealjs\n---\n```\n:::\n\n\n* Podemos ter interesse em alterar o tipo de incrementação das listas, ou o tipo de transição dos slides.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long \nlang: pt\n\nfig-align: center\nfig-width: 10\nfig-height: 12\n\ntoc: true\ntoc-depth: 3\ntoc-title: \"Agenda\"\n\nbibliography: references.bib\n\nformat: \n  revealjs:\n    incremental: true\n    transition: zoom\n---\n```\n:::\n\n\n* Podemos alterar o tema de uma apresentação da mesma maneira que no relatório. A lista de temas disponíveis para slides está [aqui](https://quarto.org/docs/presentations/revealjs/themes.html).\n\n### 8.3.1 Alterando slides\n\nPara criarmos uma coluna em slide basta utilizarmos o seguinte código:\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n:::: {.columns}\n\n::: {.column width=\"40%\"}\nColuna 1\n:::\n\n::: {.column width=\"60%\"}\nColuna 2\n:::\n\n::::\n```\n:::\n\n\n* Para criarmos abas nos slides basta utilizar o código.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n::: {.panel-tabset}\n\n### Tab A\n\nConteúdo da aba A.\n\n### Tab B\n\nConteúdo da aba B.\n\n:::\n```\n:::\n\n::: {.cell}\n\n```{.latex .cell-code}\n---\ntitle: \"Seu Título Aqui\"\nsubtitle: \"Seu Subtítulo Aqui\"\nauthor: \"Seu Nome aqui\"\ndate: 10/10/2023\ndate-format: long \nlang: pt\ntitle-block-style: none\n\nfig-align: center\nfig-width: 10\nfig-height: 12\n\ntoc: true\ntoc-depth: 3\ntoc-title: \"Agenda\"\n\nformat: \n  pdf: \n    geometry: \n      - top=30mm\n      - bottom=20mm\n      - left=20mm\n      - right=20mm\n  html:\n    code-fold: true\n    code-summary: \"R\"\n    code-overflow: scroll\n    code-link: true\n    code-tools: true\n    code-line-numbers: true\n    fontcolor: '#C25E8C'\n    linkcolor: '#00C9BA'\n    html-math-method: katex\n    citations-hover: true\n    citation-location: margin\n    theme:\n     light: flatly\n     dark: darkly\n    fontsize: 1.1em\n    highlight-style: dracula\n  docx: default\n---\n```\n:::\n\n\n\n## 8.4 Aplicativos Dinâmicos: Introdução aos Aplicativos Shiny para Análise de Dados\n\nOs aplicativos Shiny são uma ferramenta poderosa na análise de dados interativa. Eles permitem que cientistas de dados e analistas criem **interfaces de usuário interativas para explorar dados, visualizar resultados e compartilhar *insights* de uma forma intuitiva e acessível**. Neste capítulo, exploraremos os conceitos fundamentais do Shiny, que servirão como alicerce para o desenvolvimento de aplicativos interativos.\n\n### 8.4.1 Estrutura de um Aplicativo Shiny \n\nPara compreender a construção de um aplicativo Shiny, é fundamental ter um conhecimento sólido sobre a sua estrutura. Um aplicativo Shiny é um ambiente interativo que combina elementos de **interface do usuário** (UI) com **lógica de servidor** (Server) para criar uma experiência de análise de dados acessível, completa e interativa.\n\nA estrutura de um aplicativo Shiny é dividida em **duas** partes distintas, cada uma desempenhando um papel distinto em seu funcionamento. Vamos explorar essas duas partes em detalhes.\n\n#### 8.4.1.1 Interface do Usuário (UI) \n\nA Interface do Usuário (UI) é a parte do aplicativo Shiny que lida com a **aparência e a disposição dos elementos visuais** com os quais os usuários interagem. Ela é responsável por criar a experiência visual e agradável que os usuários veem ao utilizar o aplicativo. Na UI, você define quais widgets serão exibidos, como botões, caixas de seleção e gráficos, e como eles serão organizados na tela. Essa parte do aplicativo é projetada para tornar a análise de dados intuitiva e fácil de usar.\n\n#### 8.4.1.2 Lógica do Servidor (Server)\n\nA Lógica do Servidor (Server) é a parte do aplicativo Shiny que controla o **funcionamento interno do aplicativo**. Ela lida com a manipulação de eventos, acesso e processamento de dados, e a atualização dinâmica da interface do usuário em resposta às ações dos usuários. O servidor é onde você cria as funções que definem como o aplicativo se comportará, como ele processará os dados, e como responderá às interações dos usuários. É a espinha dorsal que permite que o aplicativo funcione de forma interativa e responsiva.\n\nA interação entre a UI e o Server é o que torna os aplicativos Shiny tão poderosos. Quando um usuário realiza uma ação na interface do usuário, como clicar em um botão, a ação é capturada e enviada para o servidor para processamento. O servidor, por sua vez, responde a essa ação, atualizando a interface do usuário de acordo com a lógica predefinida.\n\nCompreender a estrutura fundamental de um aplicativo Shiny é o primeiro passo para se aventurar na criação de aplicativos interativos e visualizações de dados dinâmicas.\n\n### 8.4.2 Reatividade\n\nA reatividade é um dos conceitos centrais e mais poderosos nos aplicativos Shiny. **Ela se refere à capacidade dos aplicativos Shiny de responder dinamicamente às ações dos usuários e às mudanças nos dados, atualizando automaticamente a interface do usuário e os resultados apresentados**. Essa característica fundamental é o que torna os aplicativos Shiny tão eficazes na análise de dados interativa.\n\nA reatividade é implementada através de uma série de princípios e técnicas que permitem que os aplicativos Shiny sejam sensíveis a mudanças, **sem a necessidade de recarregar a página ou executar comandos manualmente**. Os principais elementos da reatividade em aplicativos Shiny são:\n\n1. **Dependências Reativas**: Em um aplicativo Shiny, você especifica quais dados ou eventos o código no servidor depende. Isso significa que o aplicativo monitora **automaticamente** essas dependências e atualiza as partes afetadas quando elas mudam. **Por exemplo, se um gráfico depende de um conjunto de dados, ele será atualizado sempre que os dados forem alterados**.\n\n2. **Observadores Reativos**: Observadores reativos são funções no servidor que **observam as dependências reativas** e determinam quando uma ação deve ser tomada em resposta a uma mudança. Eles são responsáveis por **atualizar** a UI e realizar outras operações, como cálculos, quando ocorre uma alteração nas dependências. Isso significa que, quando um usuário interage com um widget ou os dados são atualizados, os observadores reativos **desencadeiam a atualização correspondente na interface do usuário**.\n\n4. **Reatividade Cruzada**: Os aplicativos Shiny são capazes de lidar com múltiplas dependências reativas e observadores reativos interconectados. Isso permite que diferentes partes do aplicativo reajam entre si, criando uma experiência rica e interativa para o usuário. Por exemplo, a seleção de uma região em um gráfico pode influenciar a exibição de estatísticas específicas em outra parte do aplicativo.\n\nAgora, exploraremos cada parte, a UI e o Server, em detalhes e demonstraremos como elas se combinam para criar experiências de análise de dados interativas.\n\n### 8.4.3 Exemplo Prático\n\nNo RStudio, crie um novo aplicativo Shiny. Clique em `Novo > Shiny Web App …`, dê um nome ao seu aplicativo, e selecione` multiple file`, escolha o local para salvar seu aplicativo. Ao seguir esses passos será salvo dentro de uma pasta com o nome do app dois arquivos: `server.R` e` ui.R`, contendo o servidor e a interface do usuário, respectivamente.\n\n#### 8.4.3.1 Rodando o aplicativo\n\nPara testar seu aplicativo, basta clicar no botão **RunApp**<i class=\"fa-solid fa-play\" aria-label=\"play\"></i>.\n\nNo console do R a seguinte mensagem irá aparecer:\n\n<code>Listening on http://127.0.0.1:4450</code>\n\nIsso informa a URL na qual seu aplicativo pode ser encontrado: 127.0.0.1 é um endereço padrão que significa “este computador” e 4450 é um número de porta atribuído aleatoriamente. Você pode inserir essa URL em qualquer navegador da web compatível para abrir outra cópia do seu aplicativo.\n\n**Observe também que o R está ocupado**: o prompt do R não é visível, e a barra de ferramentas do console exibe um ícone de sinal de parada. Enquanto um aplicativo Shiny está em execução, ele “bloqueia” o console do R. Isso significa que você não pode executar novos comandos no console do R até que o aplicativo Shiny seja interrompido.\n\nVocê pode interromper o aplicativo e retornar ao console usando uma destas opções:\n\n* Clique no ícone de sinal de parada na barra de ferramentas do console do R.\n\n* Clique no console e pressione Esc (ou pressione Ctrl + C se você não estiver usando o RStudio).\n\n* Feche a janela do aplicativo Shiny.\n\nO fluxo de trabalho básico no desenvolvimento de aplicativos Shiny é escrever algum código, iniciar o aplicativo, interagir com o aplicativo, escrever mais código e repetir. **Se estiver usando o RStudio, você nem precisa interromper e reiniciar o aplicativo para ver suas alterações**; você pode pressionar o botão “Recarregar aplicativo” na caixa de ferramentas ou usar o atalho de teclado Cmd/Ctrl + Shift + Enter.\n\n#### 8.4.3.2 Analisando o código da Interface com o Usuário (UI)\n\n* `fluidPage()`: é uma função do Layout, ela quem configura a estrutura básica da página.\n\n* `sidebarLayout()`: cria um layout com uma barra lateral (**`sidebarPanel()`**) e uma área principal (**`mainPanel()`**). A barra lateral é exibida com uma cor de fundo distinta e normalmente contém controles de entrada. A área principal ocupa 2/3 da largura horizontal e normalmente contém saídas (outputs).\n\n  * **`sidebarPanel()`**: Formata a barra lateral do aplicativo. Normalmente é onde temos os botões de seleção. Nesse caso, temos um botão de arraste `sliderInput()`. Poderíamos ter um botão de seleção como o `checkboxInput()`.\n\n  * **`mainPanel()`**: Incluí a saída do aplicativo. Neste caso, a saída é uma figura, portanto utilizamos um **plotOutput()**, caso nossa saída fosse uma tabela, poderiamos utilizar o **tableOutput()**. Note que a saída inclui o ID do gráfico a ser apresentado `(distPlot)`.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\nlibrary(shiny)\n\n# Defina uma UI que plote um histograma\nfluidPage(\n\n    # Titulo\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Layout separado em painel lateral e painel principal\n    sidebarLayout(\n        sidebarPanel( ## Definicoes do painel lateral\n            sliderInput(\"bins\", ## Nome do ID do input\n                        \"Number of bins:\", ## O texto que aparece no app\n                        min = 1, ## limite inferior\n                        max = 50, ## limite superior\n                        value = 30 ## valor de default)\n        ),\n\n## Definição do painel principal\n        mainPanel( ## O que deve aparecer no painel principal\n            plotOutput(\"distPlot\") ## Saída \n        )\n    )\n)\n```\n:::\n\n\n### 8.4.3.3 Analisando o código do Servidor\n\nO servidor apresenta uma função com três argumentos: - Input: Lido no UI - Output: O que queremos que saia para a UI - Session: A sessão.\n\nO objeto de input vai incluir os elementos passados pelo usuário no botão de arraste\n\n\n::: {.cell}\n\n```{.latex .cell-code}\nlibrary(shiny)\n\n\nfunction(input, output, session) {\n\n    output$distPlot <- renderPlot({\n\n        # crie o número de bins do histograma baseado em input$bins passado pelo ui.R\n        x    <- faithful[, 2]\n        bins <- seq(min(x), \n                    max(x), \n                    length.out = input$bins + 1)\n\n        # faça o histograma utilizando o input \n        hist(x, breaks = bins, \n             col = 'darkgray', \n             border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n\n    })\n\n}\n```\n:::\n\n\nAgora que entendemos o básico do aplicativo, vamos construir dois aplicativos distintos.\n\n### 8.4.4 Aplicativo 1. Gráfico utilizando os dados do tamanho das nadadeiras dos pinguins\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n## UI.R\nlibrary(shiny)\nlibrary(shinythemes)\n\nfluidPage(\n  theme = shinytheme(\"cerulean\"), \n  \n  titlePanel(\"Vamos criar um gráfico\"), \n  \n  sidebarLayout(\n    sidebarPanel(\n      style = \"background-color: #CEE26B;\", \n      \n      checkboxGroupInput(\"sp\", \n                         choices = c(\"Adelie\", \"Gentoo\", \"Chinstrap\"),\n                         selected = c(\"Adelie\", \"Gentoo\", \"Chinstrap\"),\n                         inline = TRUE,\n                         label = \"Qual espécie\"), \n      sliderInput(\"peso_g\", \n                  label = \"Qual a faixa de peso(g)?\",\n                  min = 2500, \n                  max = 6500, \n                  step = 100, \n                  dragRange = TRUE, \n                  value = c(2500, 5000))\n    ), \n    mainPanel = mainPanel(\n    \n    plotOutput(\"PlotPinguins\", width = \"100%\")),\n    position = \"right\"\n  )\n  \n)\n```\n:::\n\n::: {.cell}\n\n```{.latex .cell-code}\n## server.R\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\nfunction(input, output, session) {\n  \n  output$PlotPinguins <- \n    renderPlot({\n      \n      x <- penguins %>% \n        filter(body_mass_g > input$peso_g[1] & \n                 body_mass_g < input$peso_g[2]) %>% \n        filter(species %in% input$sp) \n      \n      p1 = ggplot(x) +\n        aes(\n          x = \"\",\n          y = flipper_length_mm,\n          fill = species,\n          colour = species\n        ) +\n        geom_violin(adjust = 1L, scale = \"count\") +\n        scale_fill_manual(\n          values = c(Adelie = \"#E76589\",\n                     Chinstrap = \"#8D619B\", \n                     Gentoo = \"#3E5475\")\n        ) +\n        scale_color_manual(\n          values = c(Adelie = \"#E76589\",\n                     Chinstrap = \"#8D619B\", \n                     Gentoo = \"#3E5475\")\n        ) +\n        coord_flip() +\n        theme_minimal() +\n        labs(x = \"Espécie\", \n             y = \"Nadadeira (mm)\", \n             color = element_blank(), \n             fill = element_blank()) + \n        theme(legend.position = \"bottom\", \n              text = element_text(size = 30))\n      \n      print(p1)\n    })\n}\n```\n:::\n\n\nCaso o objetivo esteja em um utilizar um gráfico interativo do Plotly, por exemplo, devemos alterar as funções que fazem as chamadas e criações dos gráficos. Por exemplo:\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n## ui.R\n## \nlibrary(shiny)\nlibrary(shinythemes)\n\n# Define UI for application that draws a histogram\nfluidPage(\n  theme = shinytheme(\"cerulean\"), \n  \n  titlePanel(\"Vamos criar um gráfico\"), \n  \n  sidebarLayout(\n    sidebarPanel(\n      style = \"background-color: #CEE26B;\", \n      \n      checkboxGroupInput(\"sp\", \n                         choices = c(\"Adelie\", \"Gentoo\", \"Chinstrap\"),\n                         selected = c(\"Adelie\", \"Gentoo\", \"Chinstrap\"),\n                         inline = TRUE,\n                         label = \"Qual espécie\"), \n      sliderInput(\"peso_g\", \n                  label = \"Qual a faixa de peso(g)?\",\n                  min = 2500, \n                  max = 6500, \n                  step = 100, \n                  dragRange = TRUE, \n                  value = c(2500, 5000))\n    ), \n    mainPanel = mainPanel(\n    \n    plotly::plotlyOutput(\"PlotPinguins\")),\n    position = \"right\"\n  )\n  \n)\n```\n:::\n\n::: {.cell}\n\n```{.latex .cell-code}\n## server.R\n\n\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\nfunction(input, output, session) {\n  \n  output$PlotPinguins <- \n    plotly::renderPlotly({\n      \n      x <- penguins %>% \n        filter(body_mass_g > input$peso_g[1] & \n                 body_mass_g < input$peso_g[2]) %>% \n        filter(species %in% input$sp) \n      \n      p1 = ggplot(x) +\n        aes(\n          x = \"\",\n          y = flipper_length_mm,\n          fill = species,\n          colour = species\n        ) +\n        geom_violin(adjust = 1L, scale = \"count\") +\n        scale_fill_manual(\n          values = c(Adelie = \"#E76589\",\n                     Chinstrap = \"#8D619B\", \n                     Gentoo = \"#3E5475\")\n        ) +\n        scale_color_manual(\n          values = c(Adelie = \"#E76589\",\n                     Chinstrap = \"#8D619B\", \n                     Gentoo = \"#3E5475\")\n        ) +\n        coord_flip() +\n        theme_minimal() +\n        labs(x = \"Espécie\", \n             y = \"Nadadeira (mm)\", \n             color = element_blank(), \n             fill = element_blank()) + \n        theme(legend.position = \"bottom\", \n              text = element_text(size = 30))\n      \n      plotly::ggplotly(p1)\n      \n    })\n  \n}\n```\n:::\n\n\n### 8.4.5 Aplicativo 2: Criando Tabs\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## ui.R \n\n# Define UI for random distribution app ----\nrequire(shiny)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: shiny\n```\n:::\n:::\n\n::: {.cell}\n\n```{.latex .cell-code}\nui <- fluidPage(\n  \n  # Título do APP\n  titlePanel(\"Tabsets\"),\n  \n  # Layout com Barra Lateral\n  sidebarLayout(\n    \n    # Barra lateral com os Inputs\n    sidebarPanel(\n      \n      # Input: Selecione uma Distribuição\n      radioButtons(\"dist\", \"Distribuição:\",\n                   c(\"Normal\" = \"norm\",\n                     \"Uniforme\" = \"unif\",\n                     \"Log-normal\" = \"lnorm\",\n                     \"Exponencial\" = \"exp\")),\n      \n      # Adcione um espaço\n      br(),\n      \n      # Input: Número de observações\n      sliderInput(\"n\",\n                  \"Number of observations:\",\n                  value = 500,\n                  min = 1,\n                  max = 1000)\n      \n    ),\n    \n    # Painel com os outputs\n    mainPanel(\n      \n      # Output: Tabset com gráfico, sumário e tabela\n      tabsetPanel(type = \"tabs\",\n                  tabPanel(\"Gráfico\", plotOutput(\"plot\")),\n                  tabPanel(\"Sumário\", verbatimTextOutput(\"summary\")),\n                  tabPanel(\"Tabela\", tableOutput(\"table\"))\n      )\n      \n    )\n  )\n)\n```\n:::\n\n::: {.cell}\n\n```{.latex .cell-code}\n# server.R \n# \n# Define a lógica do servidor para a distribuição\nserver <- function(input, output) {\n  \n  # Expressão reativa para gerar a distribuição solicitada ----\n  # Isso é chamado sempre que as entradas mudam. As funções de saída\n  # definidas abaixo, então, utilizam o valor calculado a partir desta expressão\n  d <- reactive({\n    dist <- switch(input$dist,\n                   norm = rnorm,\n                   unif = runif,\n                   lnorm = rlnorm,\n                   exp = rexp,\n                   rnorm)\n    \n    dist(input$n)\n  })\n  \n  # Gere um gráfico dos dados ----\n  # Também usa as entradas para criar o rótulo do gráfico. Observe que as\n  # dependências das entradas e da expressão reativa dos dados são\n  # rastreadas e todas as expressões são chamadas na sequência\n  # indicada.\n  \n  output$plot <- renderPlot({\n    dist <- input$dist\n    n <- input$n\n    \n    hist(d(),\n         main = paste(\"r\", dist, \"(\", n, \")\", sep = \"\"),\n         col = \"#007bc2\", border = \"white\")\n  })\n  \n  # Crie o sumário dos dados ----\n  output$summary <- renderPrint({\n    summary(d())\n  })\n  \n  # Gere uma tabela com os dados\n  output$table <- renderTable({\n    d()\n  })\n  \n}\n```\n:::\n\n\n\n### 8.4.6 ShinyUiEditor\n\nPara criar a interface com o usuário de maneira mais simples, podemos utilizar o ShinyUiEditor. Para saber mais, clique (aqui)[https://rstudio.github.io/shinyuieditor/].\n\n\n::: {.cell}\n\n```{.latex .cell-code}\ninstall.packages(\"remotes\")\nremotes::install_github(\"rstudio/shinyuieditor\")\n```\n:::\n\n\n## 8.5 Materiais Recomendados\n\n### 8.5.1 Para Apresentações\n\n* Para saber mais sobre personalização de slides\n  * [Quarto](https://quarto.org/docs/presentations/)\n  * [RevealJS](https://revealjs.com/)\n  \n* Para criar seu próprio tema é necessário saber um pouco de CSS. Aprenda CSS jogando:\n  * [Froggy](https://flexboxfroggy.com/)\n  * [CSSBattle](https://cssbattle.dev/)\n  * [Grid Garden](https://cssgridgarden.com/)\n  * [CSS Diner](https://flukeout.github.io/)\n\n### 8.5.2 Para Shiny\n\n* Livro base para aprender Shiny: [Mastering Shiny](https://mastering-shiny.org/)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}