{
  "hash": "1a849e851a1d76c3745170bd0715fc8b",
  "result": {
    "markdown": "---\nalways_allow_html: true\ntitle: \"5  Funções e Expressões\"\n---\n\n\n## 5.1 Funções \n\nUma função é um conjunto de instruções que realizam uma tarefa específica quando chamadas. Elas desempenham um papel crucial na programação, permitindo a modularização e **reutilização do código**. As funções em `R` seguem uma estrutura geral:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnome_da_funcao <- function(argumentos) {\n  # Corpo da função\n  # Instruções para realizar a tarefa\n  return(resultado) # Resultado da função\n}\n```\n:::\n\n\n* **nome_da_funcao**: É o nome atribuído à função, que deve ser descritivo e significativo.\n\n* **argumentos**: São os parâmetros que a função recebe como entrada. Eles podem ser opcionais ou obrigatórios, dependendo da função.\n\n* **Corpo da função**: É onde as operações desejadas são definidas usando R.\n\n* **return(resultado)**: A função pode opcionalmente retornar um resultado calculado. Se não especificado, a função retorna implicitamente o último valor calculado. É uma boa prática explicitamente definir o que a função deve retornar.\n\n### 5.1.1 Exemplo\nSuponha que temos interesse em calcular a média de uma determinada variável em um banco de dados e gostaríamos de aplicar essa função diversas vezes. Vamos demonstrar isso utilizando o banco de dados “iris”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"iris\")\n\nmedia_sepal_len = round(sum(iris$Sepal.Length)/length(iris$Sepal.Length),2)\nmedia_sepal_len\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.84\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmedia_sepal_wid = round(sum(iris$Sepal.Width)/length(iris$Sepal.Width),2)\nmedia_sepal_wid\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.06\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmedia_petal_len = round(sum(iris$Petal.Length)/length(iris$Petal.Length),2)\nmedia_petal_len\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.76\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmedia_petal_wid = round(sum(iris$Petal.Width)/length(iris$Petal.Width),2)\nmedia_petal_wid\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.2\n```\n:::\n:::\n\n\nTemos de repetir a mesma operação quatro vezes. Poderiamos simplesmente criar uma função chamada *`média`* e não precisar repetir o mesmo procedimento multiplas vezes. Vamos definir nossa primeira função em R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nminha_media <- function(vetor_de_dados){\n  media = sum(vetor_de_dados)/length(vetor_de_dados)\n  media = round(media, 2)\n  return(media)\n}\n\nminha_media(iris$Sepal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.84\n```\n:::\n:::\n\n\nSuponha que tenhamos interesse em que o número de casas decimais seja definido pelo usuário:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nminha_media_arredond <- function(vetor_de_dados, arredondamento = 5){\n  media = sum(vetor_de_dados)/length(vetor_de_dados)\n  media = round(media, arredondamento)\n  return(media)\n}\n\nminha_media(iris$Sepal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.84\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nminha_media_arredond(iris$Sepal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.84333\n```\n:::\n:::\n\n\nPodemos estar interessados em calcular o Desvio Padrão Amostral.\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_desvio_padrao_amostral <- function(vetor) {\n  media <- minha_media_arredond(vetor) \n  diferenca <- vetor - media  # Calcula as diferenças em relação à média\n  quadrados <- diferenca^2  # Calcula os quadrados das diferenças\n  variancia <- sum(quadrados) / (length(vetor) - 1)  # Calcula a variância\n  desvio_padrao <- sqrt(variancia)  # Calcula o desvio padrão\n  return(desvio_padrao)\n}\n\nmeu_desvio_padrao_amostral(iris$Sepal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8280661\n```\n:::\n:::\n\n\nCom o desvio padrão amostral e a média podemos calcular o coeficiente de variação (CV). O CV é dado por\n$$CV = \\frac{Desvio \\ Padrão}{Média} \\ X \\ 100$$\n\nPodemos implementar essa função, e para isso, podemos utilizar as duas funções que implementamos anteriormente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_coeficiente_variacao <- function(vetor, arredondamento = 2) {\n  media <- minha_media_arredond(vetor, arredondamento = arredondamento)  # Calcula a média\n  desvio_padrao <- meu_desvio_padrao_amostral(vetor)  # Calcula o desvio padrão\n  coeficiente_variacao <- (desvio_padrao / media) * 100  # Calcula o CV em porcentagem\n  coeficiente_variacao = round(coeficiente_variacao, arredondamento)\n  return(coeficiente_variacao)\n}\n\nmeu_coeficiente_variacao(iris$Sepal.Length, arredondamento = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14.18\n```\n:::\n:::\n\n\nSuponha que temos interesse em retornar ao usuário mais do que um valor, no nosso exemplo do CV temos interesse em retornar a média, o desvio padrão e o CV. Podemos fazer isso de diversas maneiras, aqui veremos apenas duas: retornar um data.frame e uma lista nomeada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_coeficiente_variacao2 <- function(vetor, arredondamento = 2) {\n  media <- minha_media_arredond(vetor, arredondamento = arredondamento)  # Calcula a média\n  desvio_padrao <- meu_desvio_padrao_amostral(vetor)  # Calcula o desvio padrão\n  coeficiente_variacao <- (desvio_padrao / media) * 100  # Calcula o CV em porcentagem\n  coeficiente_variacao = round(coeficiente_variacao, arredondamento)\n  return(data.frame(CV = coeficiente_variacao, \n                    média = media, \n                    dp = desvio_padrao))\n  \n}\n\nmeu_coeficiente_variacao2(iris$Sepal.Length, arredondamento = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     CV média        dp\n1 14.18  5.84 0.8280661\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmeu_coeficiente_variacao3 <- function(vetor, arredondamento = 2) {\n  media <- minha_media_arredond(vetor, arredondamento = arredondamento)  # Calcula a média\n  desvio_padrao <- meu_desvio_padrao_amostral(vetor)  # Calcula o desvio padrão\n  coeficiente_variacao <- (desvio_padrao / media) * 100  # Calcula o CV em porcentagem\n  coeficiente_variacao = round(coeficiente_variacao, arredondamento)\n  return(list(CV = coeficiente_variacao, \n              média = media, \n              dp = desvio_padrao))\n  \n}\n\nmeu_coeficiente_variacao3(iris$Sepal.Length, arredondamento = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$CV\n[1] 14.18\n\n$média\n[1] 5.84\n\n$dp\n[1] 0.8280661\n```\n:::\n:::\n\n\n\n### 5.1.2 Mensagens\n\nNo R existem diversos tipos de mensagem que podem ser geradas dentro de uma função, as principais são as *messages* e os *warnings*.\n\nAs mensagens em R são usadas para fornecer informações ou feedback ao usuário durante a execução de uma função ou script. Elas são úteis para comunicar detalhes sobre o progresso do código ou resultados intermediários.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -5\nif (x < 0) {\n  message(\"O valor de x é negativo.\")\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nO valor de x é negativo.\n```\n:::\n:::\n\n\nOs warnings são mensagens que alertam o usuário sobre situações que não são necessariamente erros, mas que podem indicar problemas ou comportamentos inesperados em um código. Eles são geralmente usados para chamar a atenção do usuário para possíveis questões que precisam ser consideradas. No entanto, o código continuará sendo executado após a exibição de um aviso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -5\nif (x < 0) {\n  warning(\"O valor de x é negativo.\")\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: O valor de x é negativo.\n```\n:::\n:::\n\n\nTambém podemos forçar a parada da função caso seja um erro.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -5\nif (x < 0) {\n  stop(\"O valor de x é negativo.\")\n}\n```\n:::\n\n\n## 5.2 Controle de Fluxo\n\nO controle de fluxo refere-se às estruturas que permitem tomada de decisões e execução de diferentes blocos com base em condições específicas. Podemos usar várias construções para controlar o fluxo de execução, as principais são: Estruturas Condionais e Estruturas de Repetição. Na aula de hoje focaremos apenas nas estruturas condicionais e na próxima em estruturas de repetição.\n\n### 5.2.1 Estruturas Condicionais (If-else)\n\nAs estruturas condicionais permitem a execução um bloco de código se uma condição for verdadeira e outro bloco de código se a condição for falsa.\n\nA estrutura é basicamente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condicao) {\n  # Código a ser executado se a condição for verdadeira\n} else {\n  # Código a ser executado se a condição for falsa\n}\n```\n:::\n\n\nExemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidade <- 25\n\nif (idade >= 18) {\n  cat(\"Você é maior de idade.\\n\")\n} else {\n  cat(\"Você é menor de idade.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVocê é maior de idade.\n```\n:::\n:::\n\n\nAs estruturas condicionais podem ser aninhadas, por exemplo, podemos ter interesse em classificar as notas dos alunos em diferentes faixas, como “A”, “B”, “C” ou “D”, com base na pontuação. As notas são geralmente classificadas de acordo com um intervalo específico de pontos. Notas acima de 90 são consideradas A, notas entre 80 e 90 são B, notas entre 70 e 80 são C, ou D caso contrário.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npontuacao = 90\n\nif (pontuacao >= 90) {\n  nota = \"A\"\n} else {\n  if (pontuacao >= 80) {\n    nota = \"B\"\n  } else {\n    if (pontuacao >= 70) {\n      nota = \"C\"\n    } else {\n      nota = \"D\"\n    }\n  }\n}\n\nnota\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\"\n```\n:::\n:::\n\n\nPoderíamos estar interessados em realizar esse procedimento múltiplas vezes, e uma forma de resolvermos esse problema podemos simplesmente passar para uma função:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclassifica_nota <- function(pontuacao) {\n  if (pontuacao >= 90) {\n    nota <- \"A\"\n  } else {\n    if (pontuacao >= 80) {\n      nota <- \"B\"\n    } else {\n      if (pontuacao >= 70) {\n        nota <- \"C\"\n      } else {\n        nota <- \"D\"\n      }\n    }\n  }\n  cat(paste(\"A nota do aluno é:\", nota))\n  return(nota)\n}\n\npontuacao_aluno <- 85\nnota <- classifica_nota(pontuacao_aluno)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA nota do aluno é: B\n```\n:::\n:::\n\n\nPodemos estar interessado em criar uma função para determinarmos o **Quadrante de um Ponto no Plano Cartesiano**, essa função recebe como entrada dois valores, as coordenadas (x, y).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrante <- function(x, y) {\n  if (x > 0) {\n    if (y > 0) {\n      quadrante = \"Quadrante 1\"\n      \n      cat(paste0(\"O ponto (\", x, \", \", y, \") pertence ao \",  quadrante))\n      return(quadrante)\n    } else {\n      quadrante = \"Quadrante 4\"\n      \n      cat(paste0(\"O ponto (\", x, \", \", y, \") pertence ao \",  quadrante))\n    }\n  } else {\n    if (y > 0) {\n      quadrante = \"Quadrante 2\"\n      \n      cat(paste0(\"O ponto (\", x, \", \", y, \") pertence ao \",  quadrante))\n    } else {\n      quadrante = \"Quadrante 3\"\n      \n      cat(paste0(\"O ponto (\", x, \", \", y, \") pertence ao \",  quadrante))\n    }\n  }\n}\n\n\nquadrante(1, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nO ponto (1, 1) pertence ao Quadrante 1\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Quadrante 1\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrante(-1, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nO ponto (-1, 1) pertence ao Quadrante 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrante(1, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nO ponto (1, -1) pertence ao Quadrante 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nquadrante(-1, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nO ponto (-1, -1) pertence ao Quadrante 3\n```\n:::\n:::\n\n\n### 5.2.2 If_else e ifelse\n\nMuitas vezes precisamos codificar valores de uma variável dentro de um banco de dados. Para isso, podemos utilizar as funções `if_else` ou `ifelse`.\n\nSuponha que queremos classificar o comprimento das pétalas em “longa”ou “curta”, para isso podemos fazer como segue:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(magrittr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: magrittr\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: dplyr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niris %<>% \n  mutate(cat_petal.len = ifelse(Petal.Length > mean(Petal.Length), \"Longa\", \"Curta\"))\n\niris %<>% \n  mutate(cat_petal.len2 = if_else(Petal.Length > mean(Petal.Length), \"Longa\", \"Curta\"))\n```\n:::\n\n\n### 5.2.3 Switch\n\nO comando `switch` é outra construção de controle de fluxo que permite escolher entre várias alternativas com base em um valor especificado. É útil quando você precisa executar um bloco de código diferente para diferentes valores de uma variável. A sintaxe básica do switch em R é a seguinte:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nswitch(expressao, caso1, caso2, ..., casoN)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndia_da_semana <- \"segunda\"\n\nmensagem <- switch(dia_da_semana,\n  \"segunda\" = \"Hoje é segunda-feira.\",\n  \"terca\" = \"Hoje é terça-feira.\",\n  \"quarta\" = \"Hoje é quarta-feira.\",\n  \"quinta\" = \"Hoje é quinta-feira.\",\n  \"sexta\" = \"Hoje é sexta-feira.\",\n  \"sabado\" = \"Hoje é sábado.\",\n  \"domingo\" = \"Hoje é domingo.\",\n  \"Outro\" = \"Dia não reconhecido.\"\n)\n\ncat(mensagem)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHoje é segunda-feira.\n```\n:::\n:::\n\n\n### 5.2.4 `case_when` \n\nSimilar ao `ifelse`, temos o `case_when` quando nosso interesse está em codificar variáveis de um banco de dados.\n\nTomemos como exemplo as medidas das sépalas, agora queremos agrupar em três categorias:\n\n* X < média - 1 desvio\n\n* média - 1 desvio < X < média + 1 desvio\n\n* X > média + 1 desvio\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris$cat_sepal = \n  case_when((iris$Sepal.Length < mean(iris$Sepal.Length) - sd(iris$Sepal.Length)) ~ \"X < media - 1 sd\", \n            (iris$Sepal.Length < mean(iris$Sepal.Length) + sd(iris$Sepal.Length)) ~ \"X < media + 1 sd\", \n            .default = \"X > media + 1 sd\")\n```\n:::\n\n\n### 5.2.5 Exercícios\n\n1. **Classificação do Combustível do Meio de Transporte**: Crie uma função chamada `classifica_combustivel` que recebe o nome de um meio de transporte como argumento e retorna o tipo de combustível que esse meio de transporte utiliza. Considere os seguintes meios de transporte e seus respectivos tipos de combustível:\n\n* Carro: Gasolina ou Diesel\n\n* Moto: Gasolina\n\n* Bicicleta: Humana (sem combustível)\n\n* Ônibus: Diesel ou Gás Natural\n\n* Trem: Eletricidade ou Diesel\n\n* Avião: Querosene\n\n* Barco: Diesel ou Gasolina\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclassifica_combustivel <- function(meio_de_transporte) {\n  meio_de_transporte <- tolower(meio_de_transporte)  # Converter para minúsculas para facilitar a comparação\n  \n  if (meio_de_transporte %in% c(\"carro\", \"moto\")) {\n    return(\"Gasolina ou Diesel\")\n  } else if (meio_de_transporte == \"bicicleta\") {\n    return(\"Humana (sem combustível)\")\n  } else if (meio_de_transporte %in% c(\"ônibus\", \"trem\")) {\n    return(\"Diesel ou Gás Natural\")\n  } else if (meio_de_transporte == \"avião\") {\n    return(\"Querosene\")\n  } else if (meio_de_transporte == \"barco\") {\n    return(\"Diesel ou Gasolina\")\n  } else {\n    return(\"Meio de transporte não reconhecido.\")\n  }\n}\n\n# Exemplos de uso da função\ncat(\"Meio de transporte: Carro\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMeio de transporte: Carro\n```\n:::\n\n```{.r .cell-code}\ncat(\"Tipo de combustível: \", classifica_combustivel(\"Carro\"), \"\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTipo de combustível:  Gasolina ou Diesel \n```\n:::\n\n```{.r .cell-code}\ncat(\"Meio de transporte: Bicicleta\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMeio de transporte: Bicicleta\n```\n:::\n\n```{.r .cell-code}\ncat(\"Tipo de combustível: \", classifica_combustivel(\"Bicicleta\"), \"\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTipo de combustível:  Humana (sem combustível) \n```\n:::\n\n```{.r .cell-code}\ncat(\"Meio de transporte: Avião\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMeio de transporte: Avião\n```\n:::\n\n```{.r .cell-code}\ncat(\"Tipo de combustível: \", classifica_combustivel(\"Avião\"), \"\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTipo de combustível:  Querosene \n```\n:::\n\n```{.r .cell-code}\ncat(\"Meio de transporte: Trem\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMeio de transporte: Trem\n```\n:::\n\n```{.r .cell-code}\ncat(\"Tipo de combustível: \", classifica_combustivel(\"Trem\"), \"\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTipo de combustível:  Diesel ou Gás Natural \n```\n:::\n\n```{.r .cell-code}\ncat(\"Meio de transporte: Patins\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMeio de transporte: Patins\n```\n:::\n\n```{.r .cell-code}\ncat(\"Tipo de combustível: \", classifica_combustivel(\"Patinete\"), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTipo de combustível:  Meio de transporte não reconhecido. \n```\n:::\n:::\n\n\n2. **Conversão de Temperatura**: Crie uma função chamada `converte_temperatura` que recebe uma temperatura em graus Celsius ou Fahrenheit como argumento e converte para graus Celsius ou Fahrenheit. A função recebe dois argumentos: A temperatura e a unidade de medida correspondente.\n\n::: {.cell}\n\n```{.r .cell-code}\nconverte_temperatura <- function(temperatura, unidade) {\n  unidade <- tolower(unidade)  # Converter para minúsculas para facilitar a comparação\n  \n  if (unidade == \"c\") {\n    # Converter de Celsius para Fahrenheit\n    temperatura_fahrenheit <- round((temperatura * 9/5) + 32, 2)\n    return(paste(temperatura, \"°C é igual a\", temperatura_fahrenheit, \"°F\"))\n  } else if (unidade == \"f\") {\n    # Converter de Fahrenheit para Celsius\n    temperatura_celsius <- round((temperatura - 32) * 5/9, 2)\n    return(paste(temperatura, \"°F é igual a\", temperatura_celsius, \"°C\"))\n  } else {\n    return(\"Unidade de temperatura não reconhecida. Use 'C' para Celsius ou 'F' para Fahrenheit.\")\n  }\n}\n\n# Exemplos de uso da função\ncat(\"Temperatura: 25°C\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperatura: 25°C\n```\n:::\n\n```{.r .cell-code}\ncat(converte_temperatura(25, \"C\"), \"\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25 °C é igual a 77 °F \n```\n:::\n\n```{.r .cell-code}\ncat(\"Temperatura: 75°F\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperatura: 75°F\n```\n:::\n\n```{.r .cell-code}\ncat(converte_temperatura(75, \"F\"), \"\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n75 °F é igual a 23.89 °C \n```\n:::\n\n```{.r .cell-code}\ncat(\"Temperatura: 100K\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperatura: 100K\n```\n:::\n\n```{.r .cell-code}\ncat(converte_temperatura(100, \"K\"), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnidade de temperatura não reconhecida. Use 'C' para Celsius ou 'F' para Fahrenheit. \n```\n:::\n:::\n\n\n3. **Calculadora de IMC**: Crie uma função chamada `calcula_imc` que recebe o peso (em quilogramas) e a altura (em metros) de uma pessoa como argumentos e calcula o Índice de Massa Corporal (IMC). Com base no IMC calculado, a função deve retornar uma mensagem que classifica a pessoa em uma das seguintes categorias: “Abaixo do Peso”, “Peso Normal”, “Sobrepeso” ou “Obesidade”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcula_imc <- function(peso, altura) {\n  # Calcular o IMC\n  imc <- peso / altura^2\n  \n  # Classificar com base no IMC\n  if (imc < 18.5) {\n    return(\"Abaixo do Peso\")\n  } else if (imc >= 18.5 && imc < 25) {\n    return(\"Peso Normal\")\n  } else if (imc >= 25 && imc < 30) {\n    return(\"Sobrepeso\")\n  } else {\n    return(\"Obesidade\")\n  }\n}\n\n# Exemplo de uso da função\npeso_exemplo <- 70  # em kg\naltura_exemplo <- 1.75  # em metros\n\nmensagem_classificacao <- calcula_imc(peso_exemplo, altura_exemplo)\n\ncat(\"Peso:\", peso_exemplo, \"kg\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPeso: 70 kg\n```\n:::\n\n```{.r .cell-code}\ncat(\"Altura:\", altura_exemplo, \"m\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAltura: 1.75 m\n```\n:::\n\n```{.r .cell-code}\ncat(\"Classificação:\", mensagem_classificacao, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClassificação: Peso Normal \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}