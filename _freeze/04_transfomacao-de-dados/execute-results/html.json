{
  "hash": "f20a08d3ac1721aeb41d3e2cee6b6b87",
  "result": {
    "markdown": "---\nalways_allow_html: true\ntitle: \"4  Transformação de dados\"\n---\n\n\n## 4.1 Pipes\n\n![](./imagens/pipes.png)\n\nUma maneira de fazermos os códigos em R mais legíveis é através da utilização dos operadores pipe. Os pipes fazem com a sequência das análises se torne mais aparente, o que torna o código muito menos complexo e mais fácil de ser alterado.\n\nTomemos como exemplo a seguinte análise: Seja `x` um vetor com 9 elementos, queremos obter um vetor ordenado do cosseno desses valores. Para fazer isso em R podemos aninhar diversas funções.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(-4:4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -4 -3 -2 -1  0  1  2  3  4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(cos(unique(x)), decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.0000000  0.5403023  0.5403023 -0.4161468 -0.4161468 -0.6536436 -0.6536436\n[8] -0.9899925 -0.9899925\n```\n:::\n:::\n\nO que torna o código pouco legível e difícil de ser interpretado.\n\nPodemos identar o código para faciliar a leitura:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(\n  cos(\n    unique(\n      x\n    )\n  ), \n  decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.0000000  0.5403023  0.5403023 -0.4161468 -0.4161468 -0.6536436 -0.6536436\n[8] -0.9899925 -0.9899925\n```\n:::\n:::\n\nContudo, ainda assim, o código não é de fácil compreensão, principalmente porque devemos ler o código de dentro para fora. Os pipes surgem como uma alternativa para solucionar esse problema, tornando os códigos mais legíveis e debugáveis. Os pipes, representados pelo operador `%>%`, são uma característica poderosa e conveniente introduzida pelo pacote `magrittr` e amplamente adotada em R para simplificar a manipulação de dados. Os pipes permitem encadear sequências de operações em uma maneira legível e intuitiva, tornando o código mais conciso e fácil de entender.\n\n**Funcionamento dos Pipes**: O operador `%>%` permite que você passe o resultado de uma expressão como o primeiro argumento de outra expressão. Isso é particularmente útil ao realizar uma série de transformações em um objeto sem a necessidade de criar variáveis intermediárias. O mesmo código que vimos anteriormente, com a utilização de pipe ficaria:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(magrittr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: magrittr\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx %>% \n  unique() %>% \n  cos() %>%\n  sort(decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.0000000  0.5403023  0.5403023 -0.4161468 -0.4161468 -0.6536436 -0.6536436\n[8] -0.9899925 -0.9899925\n```\n:::\n:::\n\n\n### 4.1.1 Uso do pipe\n\n* `x %>% f` é equivalente à `f(x)`\n* `x %>% f(y)` é equivalente à `f(x, y)`\n* `x %>% f %>% g %>% h` é equivalente à `h(g(f(x)))`\n\nO `%>%` significa que o elemento à esquerda sera avaliado pela função à direita.\n\nPodemos também utilizar o `.` como espaço reservado para o elemento à esquerda, isto é:\n\n* `x %>% f(y, .)` é equivalente à `f(y, x)`\n* `x %>% f(., y)` é equivalente à `f(x, y)`\n* `x %>% f(y, z = .)` é equivalente à `f(y, z = x)`.\n\n#### 4.1.1.1 Exemplos\n\nNote que não conseguimos utilizar o `%>%` com operadores aritiméticos. Portanto, uma alternativa é utiliarmos as funções `add()`, `subtract()`, `multiply_by()`, `raise_to_power()`, `divide_by()` etc. Para a lista completa de funções, utilize `?add`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\nrnorm(10)    %>%\n  multiply_by(5) %>%\n  add(5) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2.197622  3.849113 12.793542  5.352542  5.646439 13.575325  7.304581\n [8] -1.325306  1.565736  2.771690\n```\n:::\n:::\n\n\nOutra opção é utilizarmos os a operação entre aspas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\nrnorm(10) %>%\n  `*`(5) %>%\n  `+`(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2.197622  3.849113 12.793542  5.352542  5.646439 13.575325  7.304581\n [8] -1.325306  1.565736  2.771690\n```\n:::\n:::\n\n\n### 4.1.2 Benefícios dos Pipes\n\n* **Legibilidade**: Os pipes permitem ler o código da esquerda para a direita, refletindo a sequência de operações realizadas.\n\n* **Redução de Variáveis Intermediárias**: Com pipes, não precisamos criar variáveis intermediárias para armazenar resultados parciais.\n\n* **Encadeamento Simples**: O encadeamento de operações se torna mais intuitivo e fácil de seguir o código e procedimentos.\n\n* **Depuração**: Ao usar pipes, podemos isolar cada etapa para depuração, facilitando a identificação de erros.\n\n### 4.1.3 Pipe de atribuição\n\nMuitas vezes queremos realizar opereções e atribuir os resultados ao mesmo `data.frame` de entrada, por exemplo, podemos querer criar uma nova variável em `meu_data_frame`, porem, não temos interesse em duplicar o banco de dados. Podemos fazer uma atribuição explicita ou implicita. Para a explicita, simplismente atribuímos utilizando `=` ou `<-`, como vimos até agora durante o curso. Porém, podemos fazer uma atribuição implicita utilizando o operador `%<>%`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: dplyr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Atribuição explicita\nmeu_data_frame <- data.frame(\n  nome = c(\"Alice\", \"Bob\", \"Carol\", \"Ana\", \"João\", \"Carlos\", \"Patrícia\", \"Leonardo\"),\n  idade = c(25, 30, 28, 20, 27, 50, 60, 45),\n  salario = c(5000, 6000, 5500, 8000, 2000, 3500, 10000, 3800 ), \n  meio_de_transporte = c('onibus', 'bicicleta', 'onibus', 'carro', 'carro', 'onibus', 'onibus', 'bicicleta'))\n\nmeu_data_frame = meu_data_frame %>%\n  mutate(idade_25 = idade > 25)\n\nglimpse(meu_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 8\nColumns: 5\n$ nome               <chr> \"Alice\", \"Bob\", \"Carol\", \"Ana\", \"João\", \"Carlos\", \"…\n$ idade              <dbl> 25, 30, 28, 20, 27, 50, 60, 45\n$ salario            <dbl> 5000, 6000, 5500, 8000, 2000, 3500, 10000, 3800\n$ meio_de_transporte <chr> \"onibus\", \"bicicleta\", \"onibus\", \"carro\", \"carro\", …\n$ idade_25           <lgl> FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Atribuição implicita\nmeu_data_frame %<>% \n  mutate(idade_50 = idade > 50)\nglimpse(meu_data_frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 8\nColumns: 6\n$ nome               <chr> \"Alice\", \"Bob\", \"Carol\", \"Ana\", \"João\", \"Carlos\", \"…\n$ idade              <dbl> 25, 30, 28, 20, 27, 50, 60, 45\n$ salario            <dbl> 5000, 6000, 5500, 8000, 2000, 3500, 10000, 3800\n$ meio_de_transporte <chr> \"onibus\", \"bicicleta\", \"onibus\", \"carro\", \"carro\", …\n$ idade_25           <lgl> FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE\n$ idade_50           <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FAL…\n```\n:::\n:::\n\n\n## 4.2 Manipulação de Dados\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(data.table)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: data.table\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'data.table'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(dplyr)\nrequire(tidyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: tidyr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'tidyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:magrittr':\n\n    extract\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash <- fread(\"./datasets/Brazil Total highway crashes 2010 - 2023.csv.gz\")\n\n# Dados extraídos de https://www.kaggle.com/datasets/liamarguedas/brazil-total-highway-crashes-2010-2023\n\nglimpse(car_crash)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 864,561\nColumns: 24\n$ data                           <chr> \"01/01/2010\", \"01/01/2010\", \"01/01/2010…\n$ horario                        <chr> \"04:21:00\", \"02:13:00\", \"03:35:00\", \"07…\n$ n_da_ocorrencia                <chr> \"18\", \"20\", \"000024/2010\", \"000038/2010…\n$ tipo_de_ocorrencia             <chr> \"sem vítima\", \"sem vítima\", \"sem vítima…\n$ km                             <chr> \"167\", \"269,5\", \"77\", \"52\", \"33\", \"24\",…\n$ trecho                         <chr> \"BR-393/RJ\", \"BR-116/PR\", \"BR-290/RS\", …\n$ sentido                        <chr> \"Norte\", \"Sul\", \"Norte\", \"Norte\", \"Nort…\n$ lugar_acidente                 <chr> \"Rodovia do Aço\", \"Autopista Regis Bitt…\n$ tipo_de_acidente               <chr> \"Derrapagem\", \"Colisão Traseira\", \"COLI…\n$ automovel                      <int> 1, 2, 2, 0, 0, 1, 1, 1, 2, 1, NA, 1, 1,…\n$ bicicleta                      <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ caminhao                       <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ moto                           <int> NA, NA, 0, 1, 1, 0, NA, NA, NA, NA, 1, …\n$ onibus                         <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ outros                         <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ tracao_animal                  <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ transporte_de_cargas_especiais <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ trator_maquinas                <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ utilitarios                    <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ ilesos                         <int> 1, 3, 2, 1, 1, 1, 3, 4, 4, 1, 0, 1, 1, …\n$ levemente_feridos              <int> 0, NA, 0, 0, 0, 0, NA, NA, 5, NA, 2, NA…\n$ moderadamente_feridos          <int> 0, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, …\n$ gravemente_feridos             <int> 0, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, …\n$ mortos                         <int> 0, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, …\n```\n:::\n:::\n\n\n### 4.2.1 Seleção de Variáveis\nNo `tidyverse`, a função `select()` do pacote `dplyr` é amplamente utilizada para selecionar as colunas relevantes de um conjunto de dados. Além de selecionar colunas pelo nome, a função `select()` oferece diversas opções avançadas para facilitar a seleção e manipulação de colunas. Vamos explorar algumas dessas opções:\n\n#### 4.2.1.1 Seleção por Nome de Coluna\nA forma mais simples de usar o `select()` é especificar os nomes das colunas que você deseja manter no resultado, por exemplo, podemos estar interessados em selecionarmos a `data` e o `tipo_de_acidente`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  select(data, tipo_de_acidente) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         data tipo_de_acidente\n1: 01/01/2010       Derrapagem\n2: 01/01/2010 Colisão Traseira\n3: 01/01/2010  COLISÃO LATERAL\n4: 01/01/2010    QUEDA DE MOTO\n5: 01/01/2010    QUEDA DE MOTO\n6: 01/01/2010   SAÍDA DE PISTA\n```\n:::\n:::\n\n\n1. Seleção por Nome de Coluna que inicie com alguma palavra - `starts_with()`: Essa função permite selecionar colunas cujos nomes começam com um determinado padrão de caracteres. No nosso banco de dados, podemos estar interessados em selecionar todas as variáveis que iniciem com “tipo”.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  select(starts_with(\"tipo\")) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   tipo_de_ocorrencia tipo_de_acidente\n1:         sem vítima       Derrapagem\n2:         sem vítima Colisão Traseira\n3:         sem vítima  COLISÃO LATERAL\n4:         sem vítima    QUEDA DE MOTO\n5:         sem vítima    QUEDA DE MOTO\n6:         sem vítima   SAÍDA DE PISTA\n```\n:::\n:::\n\n\n2. Seleção por Nome de Coluna que termine com alguma palavra - `ends_with()`: Essa função permite selecionar colunas cujos nomes terminam com um determinado padrão de caracteres. No nosso banco de dados, podemos estar interessados em selecionar todas as variáveis que terminem com “feridos”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  select(ends_with(\"feridos\")) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   levemente_feridos moderadamente_feridos gravemente_feridos\n1:                 0                     0                  0\n2:                NA                    NA                 NA\n3:                 0                     0                  0\n4:                 0                     0                  0\n5:                 0                     0                  0\n6:                 0                     0                  0\n```\n:::\n:::\n\n\n3. Seleção por Nome de Coluna que contenha alguma palavra - `contains()`: Essa função permite selecionar colunas cujos nomes contenham um determinado padrão de caracteres. No nosso banco de dados, podemos estar interessados em selecionar todas as variáveis que contenham “mente”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  select(contains(\"mente\")) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   levemente_feridos moderadamente_feridos gravemente_feridos\n1:                 0                     0                  0\n2:                NA                    NA                 NA\n3:                 0                     0                  0\n4:                 0                     0                  0\n5:                 0                     0                  0\n6:                 0                     0                  0\n```\n:::\n:::\n\n\n#### 4.2.1.2 Seleção de variáveis por Tipos específicos de dados\nMuitas vezes, estamos interessados em selecionar apenas variáveis de um tipo, para tratarmos os dados da maneira mais adequada.\n\n1. Selecionar apenas variáveis numéricas: `is.numeric()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  select(where(is.numeric)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 864,561\nColumns: 15\n$ automovel                      <int> 1, 2, 2, 0, 0, 1, 1, 1, 2, 1, NA, 1, 1,…\n$ bicicleta                      <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ caminhao                       <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ moto                           <int> NA, NA, 0, 1, 1, 0, NA, NA, NA, NA, 1, …\n$ onibus                         <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ outros                         <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ tracao_animal                  <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ transporte_de_cargas_especiais <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ trator_maquinas                <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ utilitarios                    <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA,…\n$ ilesos                         <int> 1, 3, 2, 1, 1, 1, 3, 4, 4, 1, 0, 1, 1, …\n$ levemente_feridos              <int> 0, NA, 0, 0, 0, 0, NA, NA, 5, NA, 2, NA…\n$ moderadamente_feridos          <int> 0, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, …\n$ gravemente_feridos             <int> 0, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, …\n$ mortos                         <int> 0, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, …\n```\n:::\n:::\n\n\n2. Selecionar apenas variáveis characters: `is.character()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  select(where(is.character)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 864,561\nColumns: 9\n$ data               <chr> \"01/01/2010\", \"01/01/2010\", \"01/01/2010\", \"01/01/20…\n$ horario            <chr> \"04:21:00\", \"02:13:00\", \"03:35:00\", \"07:31:00\", \"04…\n$ n_da_ocorrencia    <chr> \"18\", \"20\", \"000024/2010\", \"000038/2010\", \"000027/2…\n$ tipo_de_ocorrencia <chr> \"sem vítima\", \"sem vítima\", \"sem vítima\", \"sem víti…\n$ km                 <chr> \"167\", \"269,5\", \"77\", \"52\", \"33\", \"24\", \"52\", \"40\",…\n$ trecho             <chr> \"BR-393/RJ\", \"BR-116/PR\", \"BR-290/RS\", \"BR-116/RS\",…\n$ sentido            <chr> \"Norte\", \"Sul\", \"Norte\", \"Norte\", \"Norte\", \"Sul\", \"…\n$ lugar_acidente     <chr> \"Rodovia do Aço\", \"Autopista Regis Bittencourt\", \"C…\n$ tipo_de_acidente   <chr> \"Derrapagem\", \"Colisão Traseira\", \"COLISÃO LATERAL\"…\n```\n:::\n:::\n\n\n\n3. Selecionar apenas variáveis lógicas: `is.logical()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  select(where(is.logical)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 0\nColumns: 0\n```\n:::\n:::\n\n\n#### 4.2.1.3 Seleção por critérios\n* `all_of()`, `any_of()`: Permitem usar variáveis definidas externamente como argumentos da função. Note que quando utilizamos `all_of()` todas as variáveis devem existir, já `any_of()` permite que nem todas as variáveis existam no banco de dados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvars_interesse = c(\"automovel\", \"bicicleta\", \"onibus\")\ncar_crash %>% \n  select(all_of(vars_interesse)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 864,561\nColumns: 3\n$ automovel <int> 1, 2, 2, 0, 0, 1, 1, 1, 2, 1, NA, 1, 1, 2, 2, 1, 1, NA, 1, 2…\n$ bicicleta <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, 0, NA, NA, NA, N…\n$ onibus    <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, 0, NA, NA, NA, N…\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvars_interesse2 = c(\"automovel\", \"bicicleta\", \"onibus\", \"trator\")\ncar_crash %>% \n  select(any_of(vars_interesse2)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 864,561\nColumns: 3\n$ automovel <int> 1, 2, 2, 0, 0, 1, 1, 1, 2, 1, NA, 1, 1, 2, 2, 1, 1, NA, 1, 2…\n$ bicicleta <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, 0, NA, NA, NA, N…\n$ onibus    <int> NA, NA, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, 0, NA, NA, NA, N…\n```\n:::\n:::\n\n\n### 4.2.2 Seleção de Observações\nNo pacote `dplyr` do tidyverse, a função `filter()` é amplamente utilizada para filtrar linhas de um conjunto de dados com base em condições específicas. Ela oferece diversas opções para criar filtros complexos que atendam às suas necessidades de análise. Vamos explorar diferentes tipos de filtros e como utilizá-los de maneira eficaz.\n\n#### 4.2.2.1 Filtros Simples\nFiltros simples envolvem comparações entre valores de uma coluna e um valor constante. Alguns operadores de comparação comuns incluem:\n\n* `==`: Igual a\n\n* `!=`: Diferente de\n\n* `<`: Menor que\n\n* `>`: Maior que\n\n* `<=`: Menor ou igual a\n\n* `>=`: Maior ou igual a\n\nPodemos estar interessados em filtrar as observações com pelo menos três carros envolvidos no acidente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_filtrados <- car_crash %>%\n  filter(automovel >= 3)\ndados_filtrados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             data  horario n_da_ocorrencia         tipo_de_ocorrencia      km\n    1: 01/01/2010 13:14:00             150                 sem vítima     560\n    2: 01/01/2011 23:21:00             542                 sem vítima   137,5\n    3: 01/01/2011 12:21:00             212                 sem vítima    68,8\n    4: 01/01/2011 13:55:00             135                 sem vítima     269\n    5: 01/01/2011 14:57:00             309                 sem vítima     193\n   ---                                                                       \n34384: 31/12/2021 07:00:03             115                 Sem vítima 626,434\n34385: 31/12/2021 21:43:00             388                 Sem vítima 131,806\n34386: 31/12/2021 17:36:28             247                 Sem vítima 269,670\n34387: 31/12/2022 19:53:19             571 ac02 - Acidente com Vítima 445,000\n34388: 31/12/2022 10:18:00             206        Acidente com vítima      44\n          trecho     sentido              lugar_acidente\n    1: BR-116/PR         Sul Autopista Regis Bittencourt\n    2: BR-101/SC       Norte       Autopista Litoral Sul\n    3: BR-116/SP   Pista Sul                   Novadutra\n    4: BR-116/PR       Norte Autopista Regis Bittencourt\n    5: BR-101/SC       Norte       Autopista Litoral Sul\n   ---                                                  \n34384: BR-376/SC Decrescente       Autopista Litoral Sul\n34385: BR-101/SC Decrescente       Autopista Litoral Sul\n34386: BR-116/SP   Crescente Autopista Regis Bittencourt\n34387: BR-262/MG       Oeste                    Concebra\n34388: BR-101/SP Pista Norte                       RIOSP\n                    tipo_de_acidente automovel bicicleta caminhao moto onibus\n    1:              Colisão Traseira         3        NA       NA   NA     NA\n    2:              Colisão Traseira         3        NA       NA   NA     NA\n    3: Choque em barreira New Jersey         3         0        0    0      0\n    4:                 Engavetamento         4        NA       NA   NA     NA\n    5:              Colisão Traseira         3        NA       NA   NA     NA\n   ---                                                                       \n34384:                 Engavetamento         3         0        0    0      0\n34385:                 Engavetamento         3         0        0    0      0\n34386:                 Engavetamento         3         0        0    0      0\n34387:               Colisão Lateral         3         0        0    0      0\n34388:                 Engavetamento         3         0        0    0      0\n       outros tracao_animal transporte_de_cargas_especiais trator_maquinas\n    1:     NA            NA                             NA              NA\n    2:     NA            NA                             NA              NA\n    3:      0             0                             NA               0\n    4:     NA            NA                             NA              NA\n    5:     NA            NA                             NA              NA\n   ---                                                                    \n34384:      0             0                              0               0\n34385:      0             0                              0               0\n34386:      0             0                              0               0\n34387:      0             0                              0               0\n34388:      0             0                             NA               0\n       utilitarios ilesos levemente_feridos moderadamente_feridos\n    1:          NA     14                NA                    NA\n    2:          NA      3                NA                    NA\n    3:           0     11                 0                     0\n    4:          NA      7                NA                    NA\n    5:          NA      3                NA                    NA\n   ---                                                           \n34384:           0      3                 0                     0\n34385:           0      3                 0                     0\n34386:           1      4                 0                     0\n34387:           0      2                 0                     0\n34388:           0     10                 1                     0\n       gravemente_feridos mortos\n    1:                 NA     NA\n    2:                 NA     NA\n    3:                  0      0\n    4:                 NA     NA\n    5:                 NA     NA\n   ---                          \n34384:                  0      0\n34385:                  0      0\n34386:                  0      0\n34387:                  0      0\n34388:                  0      0\n```\n:::\n:::\n\n\n#### 4.2.2.2 Filtros Combinados\nVocê pode combinar filtros usando os operadores lógicos `&` (AND) e `|` (OR) para criar condições mais complexas.\n\nPodemos estar interessados em filtrar as observações com pelo menos três carros e dois caminhões envolvidos no acidente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_filtrados <- car_crash %>%\n  filter(automovel >= 3 & caminhao > 2)\ndados_filtrados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           data  horario n_da_ocorrencia tipo_de_ocorrencia                 km\n  1: 01/02/2018 07:45:00             119         sem vítima             41,941\n  2: 01/03/2012 09:04:00             163         com vítima 111,19999694824219\n  3: 01/03/2019 00:07:00               2         sem vítima              667,5\n  4: 01/04/2011 08:32:00             223         sem vítima              222,7\n  5: 01/06/2014 16:47:00             238         com vítima            676,662\n ---                                                                          \n173: 29/11/2017 16:38:00             592         com vítima  96,30000305175781\n174: 30/10/2012 13:15:00             437         com vítima              133,2\n175: 31/03/2013 19:30:00             468         com vítima              540,5\n176: 31/03/2014 15:56:00             228         sem vítima                656\n177: 31/10/2011 06:28:00             121         com vítima                208\n        trecho     sentido        lugar_acidente tipo_de_acidente automovel\n  1: BR-101/SC       Norte Autopista Litoral Sul    Engavetamento         3\n  2: BR-116/PR         Sul Autopista Litoral Sul Colisão Traseira         3\n  3: BR-376/PR         Sul Autopista Litoral Sul    Engavetamento         8\n  4: BR-116/RJ Pista Norte             Novadutra    Engavetamento         3\n  5: BR-376/PR         Sul Autopista Litoral Sul    Engavetamento         4\n ---                                                                       \n173: BR-116/SP Pista Norte             Novadutra    Engavetamento         7\n174: BR-116/SP Pista Norte             Novadutra    Engavetamento         3\n175: BR-381/MG       Norte Autopista Fernão Dias    Engavetamento         5\n176: BR-376/PR       Norte Autopista Litoral Sul    Engavetamento         3\n177: BR-116/RJ Pista Norte             Novadutra    Engavetamento         3\n     bicicleta caminhao moto onibus outros tracao_animal\n  1:        NA        3   NA     NA     NA            NA\n  2:        NA        3    1     NA     NA            NA\n  3:        NA        4   NA     NA     NA            NA\n  4:         0        3    0      0      0             0\n  5:        NA        4   NA     NA     NA            NA\n ---                                                    \n173:        NA        3   NA     NA     NA            NA\n174:         0        3    0      0      0             0\n175:        NA        3   NA     NA     NA            NA\n176:        NA        4   NA     NA     NA            NA\n177:         0        3    0      0      1             0\n     transporte_de_cargas_especiais trator_maquinas utilitarios ilesos\n  1:                             NA              NA           1      7\n  2:                             NA              NA          NA      6\n  3:                             NA              NA          NA     29\n  4:                             NA               0           0      8\n  5:                             NA              NA          NA      3\n ---                                                                  \n173:                             NA              NA          NA     19\n174:                             NA               0           0      8\n175:                             NA              NA          NA      7\n176:                             NA              NA           2      9\n177:                             NA               0           0      6\n     levemente_feridos moderadamente_feridos gravemente_feridos mortos\n  1:                NA                    NA                 NA     NA\n  2:                 1                    NA                 NA     NA\n  3:                NA                    NA                 NA     NA\n  4:                 0                     0                  0      0\n  5:                NA                     2                  3      5\n ---                                                                  \n173:                 1                    NA                 NA     NA\n174:                 1                     0                  0      0\n175:                 1                    NA                 NA     NA\n176:                NA                    NA                 NA     NA\n177:                 1                     0                  0      0\n```\n:::\n:::\n\n\nPodemos omitir o operador lógico `&`, então a função ficaria:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_filtrados <- car_crash %>%\n  filter(automovel >= 3, caminhao > 2)\ndados_filtrados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           data  horario n_da_ocorrencia tipo_de_ocorrencia                 km\n  1: 01/02/2018 07:45:00             119         sem vítima             41,941\n  2: 01/03/2012 09:04:00             163         com vítima 111,19999694824219\n  3: 01/03/2019 00:07:00               2         sem vítima              667,5\n  4: 01/04/2011 08:32:00             223         sem vítima              222,7\n  5: 01/06/2014 16:47:00             238         com vítima            676,662\n ---                                                                          \n173: 29/11/2017 16:38:00             592         com vítima  96,30000305175781\n174: 30/10/2012 13:15:00             437         com vítima              133,2\n175: 31/03/2013 19:30:00             468         com vítima              540,5\n176: 31/03/2014 15:56:00             228         sem vítima                656\n177: 31/10/2011 06:28:00             121         com vítima                208\n        trecho     sentido        lugar_acidente tipo_de_acidente automovel\n  1: BR-101/SC       Norte Autopista Litoral Sul    Engavetamento         3\n  2: BR-116/PR         Sul Autopista Litoral Sul Colisão Traseira         3\n  3: BR-376/PR         Sul Autopista Litoral Sul    Engavetamento         8\n  4: BR-116/RJ Pista Norte             Novadutra    Engavetamento         3\n  5: BR-376/PR         Sul Autopista Litoral Sul    Engavetamento         4\n ---                                                                       \n173: BR-116/SP Pista Norte             Novadutra    Engavetamento         7\n174: BR-116/SP Pista Norte             Novadutra    Engavetamento         3\n175: BR-381/MG       Norte Autopista Fernão Dias    Engavetamento         5\n176: BR-376/PR       Norte Autopista Litoral Sul    Engavetamento         3\n177: BR-116/RJ Pista Norte             Novadutra    Engavetamento         3\n     bicicleta caminhao moto onibus outros tracao_animal\n  1:        NA        3   NA     NA     NA            NA\n  2:        NA        3    1     NA     NA            NA\n  3:        NA        4   NA     NA     NA            NA\n  4:         0        3    0      0      0             0\n  5:        NA        4   NA     NA     NA            NA\n ---                                                    \n173:        NA        3   NA     NA     NA            NA\n174:         0        3    0      0      0             0\n175:        NA        3   NA     NA     NA            NA\n176:        NA        4   NA     NA     NA            NA\n177:         0        3    0      0      1             0\n     transporte_de_cargas_especiais trator_maquinas utilitarios ilesos\n  1:                             NA              NA           1      7\n  2:                             NA              NA          NA      6\n  3:                             NA              NA          NA     29\n  4:                             NA               0           0      8\n  5:                             NA              NA          NA      3\n ---                                                                  \n173:                             NA              NA          NA     19\n174:                             NA               0           0      8\n175:                             NA              NA          NA      7\n176:                             NA              NA           2      9\n177:                             NA               0           0      6\n     levemente_feridos moderadamente_feridos gravemente_feridos mortos\n  1:                NA                    NA                 NA     NA\n  2:                 1                    NA                 NA     NA\n  3:                NA                    NA                 NA     NA\n  4:                 0                     0                  0      0\n  5:                NA                     2                  3      5\n ---                                                                  \n173:                 1                    NA                 NA     NA\n174:                 1                     0                  0      0\n175:                 1                    NA                 NA     NA\n176:                NA                    NA                 NA     NA\n177:                 1                     0                  0      0\n```\n:::\n:::\n\n\nPodemos estar interessados em filtrar as observações com pelo menos três carros OU dois caminhões envolvidos no acidente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_filtrados <- car_crash %>%\n  filter(automovel >= 3 | caminhao > 2)\ndados_filtrados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             data  horario n_da_ocorrencia         tipo_de_ocorrencia      km\n    1: 01/01/2010 13:14:00             150                 sem vítima     560\n    2: 01/01/2011 23:21:00             542                 sem vítima   137,5\n    3: 01/01/2011 12:21:00             212                 sem vítima    68,8\n    4: 01/01/2011 13:55:00             135                 sem vítima     269\n    5: 01/01/2011 14:57:00             309                 sem vítima     193\n   ---                                                                       \n39204: 31/12/2021 21:43:00             388                 Sem vítima 131,806\n39205: 31/12/2021 17:36:28             247                 Sem vítima 269,670\n39206: 31/12/2022 19:53:19             571 ac02 - Acidente com Vítima 445,000\n39207: 31/12/2022 16:29:00             343                 Sem vítima 643,000\n39208: 31/12/2022 10:18:00             206        Acidente com vítima      44\n          trecho     sentido              lugar_acidente\n    1: BR-116/PR         Sul Autopista Regis Bittencourt\n    2: BR-101/SC       Norte       Autopista Litoral Sul\n    3: BR-116/SP   Pista Sul                   Novadutra\n    4: BR-116/PR       Norte Autopista Regis Bittencourt\n    5: BR-101/SC       Norte       Autopista Litoral Sul\n   ---                                                  \n39204: BR-101/SC Decrescente       Autopista Litoral Sul\n39205: BR-116/SP   Crescente Autopista Regis Bittencourt\n39206: BR-262/MG       Oeste                    Concebra\n39207: BR-116/BA Decrescente                   Via Bahia\n39208: BR-101/SP Pista Norte                       RIOSP\n                       tipo_de_acidente automovel bicicleta caminhao moto\n    1:                 Colisão Traseira         3        NA       NA   NA\n    2:                 Colisão Traseira         3        NA       NA   NA\n    3:    Choque em barreira New Jersey         3         0        0    0\n    4:                    Engavetamento         4        NA       NA   NA\n    5:                 Colisão Traseira         3        NA       NA   NA\n   ---                                                                   \n39204:                    Engavetamento         3         0        0    0\n39205:                    Engavetamento         3         0        0    0\n39206:                  Colisão Lateral         3         0        0    0\n39207: Colisão lateral no mesmo sentido         0         0        3    0\n39208:                    Engavetamento         3         0        0    0\n       onibus outros tracao_animal transporte_de_cargas_especiais\n    1:     NA     NA            NA                             NA\n    2:     NA     NA            NA                             NA\n    3:      0      0             0                             NA\n    4:     NA     NA            NA                             NA\n    5:     NA     NA            NA                             NA\n   ---                                                           \n39204:      0      0             0                              0\n39205:      0      0             0                              0\n39206:      0      0             0                              0\n39207:      0      0             0                              0\n39208:      0      0             0                             NA\n       trator_maquinas utilitarios ilesos levemente_feridos\n    1:              NA          NA     14                NA\n    2:              NA          NA      3                NA\n    3:               0           0     11                 0\n    4:              NA          NA      7                NA\n    5:              NA          NA      3                NA\n   ---                                                     \n39204:               0           0      3                 0\n39205:               0           1      4                 0\n39206:               0           0      2                 0\n39207:               0           0      0                 0\n39208:               0           0     10                 1\n       moderadamente_feridos gravemente_feridos mortos\n    1:                    NA                 NA     NA\n    2:                    NA                 NA     NA\n    3:                     0                  0      0\n    4:                    NA                 NA     NA\n    5:                    NA                 NA     NA\n   ---                                                \n39204:                     0                  0      0\n39205:                     0                  0      0\n39206:                     0                  0      0\n39207:                     0                  0      0\n39208:                     0                  0      0\n```\n:::\n:::\n\n\n#### 4.2.2.3 Filtrando valores dentro de um intervalo\nPara filtramos valores dentro de um intervalo definido podemos utilizar as funções `between()` e `%in%`.\n\nA função `between()` é útil para filtrar valores dentro de um intervalo numérico.\n\nPodemos estar interessados em filtrar as observações com valores entre 4 e 8 motos envolvidas no acidente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados_filtrados <- car_crash %>%\n  filter(between(moto, lower = 4, upper = 8, incbounds = TRUE)) \ndados_filtrados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          data  horario n_da_ocorrencia                    tipo_de_ocorrencia\n 1: 02/02/2012 09:07:00              35                            sem vítima\n 2: 02/08/2022 14:34:00             333          Acidente com Danos Materiais\n 3: 04/02/2021 06:24:00             111                  Acidente sem Vítimas\n 4: 05/08/2021 07:12:00             118                  Acidente com Vítimas\n 5: 07/08/2021 04:53:00              35                  Acidente com Vítimas\n 6: 09/07/2021 06:08:00              70                  Acidente com Vítimas\n 7: 11/04/2019 23:50:00             526                            com vítima\n 8: 11/07/2017 16:31:00             307                            com vítima\n 9: 13/11/2016 17:15:00             146                            sem vítima\n10: 14/01/2021 06:55:00             143                  Acidente com Vítimas\n11: 16/11/2010 21:22:00             404                            com vítima\n12: 17/03/2016 06:52:00              64                   Acidente com vítima\n13: 18/03/2016 17:02:00             259                   Acidente sem Vítima\n14: 18/07/2021 09:06:00              88                  Acidente sem Vítimas\n15: 19/03/2016 05:23:00              70 Acidente sem Vítima - TRECHO CONTORNO\n16: 19/10/2020 18:40:00             240                        Acidente Fatal\n17: 20/03/2016 18:20:00             249                   Acidente com vítima\n18: 20/03/2021 22:17:00             245                  Acidente com Vítimas\n19: 20/03/2021 13:57:00             140                        Acidente Fatal\n20: 20/05/2016 07:50:00             110                            com vítima\n21: 20/10/2021 06:30:00             114                  Acidente com Vítimas\n22: 21/03/2016 08:54:00             103                   Acidente com vítima\n23: 22/01/2023 19:40:00            3192      AC01 - Acidente com VITIMA FATAL\n24: 22/03/2016 23:01:00             347                   Acidente sem Vítima\n25: 22/11/2015 10:04:00              61                            com vítima\n26: 23/01/2023 14:50:00              69                            Com vítima\n27: 25/03/2013 07:31:00             158                            com vítima\n28: 25/09/2021 06:50:00              66                  Acidente com Vítimas\n29: 26/08/2011 22:27:00             817                            com vítima\n30: 27/10/2021 12:33:00             208                  Acidente com Vítimas\n31: 28/03/2020 12:30:00             249                            com vítima\n32: 29/03/2021 23:48:00             289                  Acidente com Vítimas\n          data  horario n_da_ocorrencia                    tipo_de_ocorrencia\n                  km    trecho     sentido              lugar_acidente\n 1:             59,7 BR-153/SP       Norte             Transbrasiliana\n 2:          506,000 BR-153/GO         Sul                    Concebra\n 3:            510,3 BR-040/MG         Sul                      VIA040\n 4:            96,99 BR-040/GO         Sul                      VIA040\n 5:           552,15 BR-040/MG         Sul                      VIA040\n 6:            514,4 BR-040/MG         Sul                      VIA040\n 7:          212,269 BR-101/SC         Sul       Autopista Litoral Sul\n 8:            269,5 BR-116/PR         Sul Autopista Regis Bittencourt\n 9:              0,2 BR-050/MG       Norte                      ECO050\n10:           542,25 BR-040/MG         Sul                      VIA040\n11: 90,0999984741211 BR-381/SP       Norte       Autopista Fernão Dias\n12:              401 BR-101/ES         Sul                      ECO101\n13:              205 BR-101/ES       Norte                      ECO101\n14:              4,1 BR-040/GO       Norte                      VIA040\n15:              285 BR-101/ES         Sul                      ECO101\n16:           610,55 BR-040/MG         Sul                      VIA040\n17:              139 BR-101/ES         Sul                      ECO101\n18:             23,1 BR-040/GO       Norte                      VIA040\n19:             34,6 BR-040/MG         Sul                      VIA040\n20:          207,488 BR-101/SC       Norte       Autopista Litoral Sul\n21:            517,5 BR-040/MG         Sul                      VIA040\n22:              363 BR-101/ES         Sul                      ECO101\n23:              822 BR-040/MG          JF                      Concer\n24:               10 BR-101/ES       Norte                      ECO101\n25:            277,7 BR-101/RJ         Sul        Autopista Fluminense\n26:           80,200 BR-392/RS   Crescente                      Ecosul\n27:            180,2 BR-116/RJ Pista Norte                   Novadutra\n28:              5,5 BR-040/DF       Norte                      VIA040\n29:            153,4 BR-116/SP Pista Norte                   Novadutra\n30:           531,12 BR-040/MG         Sul                      VIA040\n31:           24,926 BR-101/SC         Sul       Autopista Litoral Sul\n32:              8,9 BR-040/MG         Sul                      VIA040\n                  km    trecho     sentido              lugar_acidente\n                              tipo_de_acidente automovel bicicleta caminhao\n 1: Choque contra objeto na faixa de rolamento        NA        NA        1\n 2:                           Colisão Traseira         0         0        0\n 3:                              Engavetamento         0         0        0\n 4:                           Colisão traseira         0         0        0\n 5:                           Colisão traseira         0         0        0\n 6:                              Engavetamento         4         0        0\n 7:                              Engavetamento         1        NA       NA\n 8:                        Colisão Transversal         1         0        0\n 9:     Choque - Veiculo parado no acostamento         1        NA       NA\n10:                           Colisão traseira         0         0        0\n11:                         Outros - Sequência        NA        NA       NA\n12:                            Colisão Lateral         1        NA        0\n13:                           Colisão Traseira         2        NA        0\n14:                            Colisão lateral         0         0        0\n15:                             Saída de Pista         2        NA        0\n16:                        Colisão transversal         0         0        1\n17:                           Colisão Traseira         1        NA        0\n18:                              Engavetamento         1         0        0\n19:                            Colisão frontal         0         0        1\n20:                              Engavetamento        NA        NA       NA\n21:                            Colisão lateral         2         0        0\n22:                            Colisão Lateral         0        NA        1\n23:                     Atropelamento - Animal        NA        NA       NA\n24:                          Veículo em Chamas         0        NA        0\n25:                              Engavetamento         1        NA       NA\n26:                             Saída de pista         0         0        0\n27:                  Abalroamento longitudinal         1         0        0\n28:                         Tombamento de Moto         0         0        0\n29:                              Queda de moto         0         0        0\n30:                            Colisão lateral         0         0        0\n31:                              Engavetamento         1        NA       NA\n32:                           Colisão traseira         2         0        0\n                              tipo_de_acidente automovel bicicleta caminhao\n    moto onibus outros tracao_animal transporte_de_cargas_especiais\n 1:    4     NA     NA            NA                             NA\n 2:    4      0      0             0                              0\n 3:    5      0      1             0                              0\n 4:    4      0      0             0                              0\n 5:    4      0      1             0                              0\n 6:    4      0      0             0                              0\n 7:    4     NA     NA            NA                             NA\n 8:    4      0      0             0                              0\n 9:    4     NA     NA            NA                             NA\n10:    4      0      0             0                              0\n11:    4     NA     NA            NA                             NA\n12:    5      0      0             0                             NA\n13:    4      0      0             0                             NA\n14:    5      0      0             0                              0\n15:    4      0      0             0                             NA\n16:    6      0      0             0                              0\n17:    4      0      0             0                             NA\n18:    4      0      0             0                              0\n19:    4      2      0             0                              0\n20:    4     NA      1            NA                             NA\n21:    4      0      0             0                              0\n22:    4      0      0             0                             NA\n23:    4     NA     NA            NA                             NA\n24:    4      0      0             0                             NA\n25:    5     NA     NA            NA                             NA\n26:    5      0      0             0                              0\n27:    4      0      0             0                             NA\n28:    4      0      1             0                              0\n29:    4      0      0             0                             NA\n30:    4      0      0             0                              0\n31:    4     NA     NA            NA                             NA\n32:    4      0      0             0                              0\n    moto onibus outros tracao_animal transporte_de_cargas_especiais\n    trator_maquinas utilitarios ilesos levemente_feridos moderadamente_feridos\n 1:              NA          NA      5                NA                    NA\n 2:               0           0      4                 0                     0\n 3:               0           0      3                 0                     0\n 4:               0           0      1                 0                     1\n 5:               0           0      0                 0                     0\n 6:               0           0      0                 1                     0\n 7:              NA          NA      1                 2                    NA\n 8:               0           0      1                 4                     0\n 9:              NA          NA      6                NA                    NA\n10:               0           0      2                 1                     0\n11:              NA          NA      4                 1                    NA\n12:              NA          NA      2                 0                     0\n13:              NA          NA      5                 0                     0\n14:               0           0      2                 0                     0\n15:              NA          NA      4                 0                     0\n16:               0           0      1                 0                     0\n17:              NA          NA      2                 2                     0\n18:               0           0      2                 0                     0\n19:               0           0      1                 0                     0\n20:              NA          NA      3                 2                    NA\n21:               0           0      0                 1                     0\n22:              NA          NA      2                 1                     0\n23:              NA          NA      1                 2                    NA\n24:              NA          NA      1                 0                     0\n25:              NA          NA      4                 1                     2\n26:               0           0      3                 1                     0\n27:               0           0      2                 4                     0\n28:               0           0      3                 0                     1\n29:               0           0      2                 2                     0\n30:               0           0      0                 1                     0\n31:              NA          NA      3                 2                    NA\n32:               0           0      1                 1                     0\n    trator_maquinas utilitarios ilesos levemente_feridos moderadamente_feridos\n    gravemente_feridos mortos\n 1:                 NA     NA\n 2:                  0      0\n 3:                  0      0\n 4:                  0      0\n 5:                  0      0\n 6:                  0      0\n 7:                  1      1\n 8:                  0      0\n 9:                 NA     NA\n10:                  0      0\n11:                 NA     NA\n12:                  1      0\n13:                  0      0\n14:                  0      0\n15:                  0      0\n16:                  0      1\n17:                  0      0\n18:                  0      0\n19:                  0      1\n20:                 NA     NA\n21:                  0      0\n22:                  0      0\n23:                  1      1\n24:                  0      0\n25:                 NA     NA\n26:                  1      0\n27:                  0      0\n28:                  0      0\n29:                  0      0\n30:                  0      0\n31:                 NA     NA\n32:                  0      0\n    gravemente_feridos mortos\n```\n:::\n:::\n\n\nA função `%in%` é usada para filtrar valores que correspondem a um conjunto de valores.\n\nPodemos estar interessados em filtrar as observações com ocorrência em alguma das seguintes operadoras: “Autopista Regis Bittencourt”, “Autopista Litoral Sul”, “Via Sul”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautopistas = c(\"Autopista Regis Bittencourt\", \"Autopista Litoral Sul\", \"Via Sul\")\n\ndados_filtrados <- car_crash %>%\n  filter(lugar_acidente %in% autopistas) \ndados_filtrados \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              data  horario n_da_ocorrencia tipo_de_ocorrencia      km\n     1: 01/01/2010 02:13:00              20         sem vítima   269,5\n     2: 01/01/2010 11:20:00             125         sem vítima      52\n     3: 01/01/2010 18:07:00             214         sem vítima      40\n     4: 01/01/2010 15:52:00             354         sem vítima     132\n     5: 01/01/2010 16:30:00             377         com vítima      35\n    ---                                                               \n203032: 31/12/2022 20:44:02             343         Com vítima 105,500\n203033: 31/12/2022 22:20:07             372         Sem vítima 158,100\n203034: 31/12/2022 22:16:59             369         Com vítima 131,163\n203035: 31/12/2022 23:23:36             386         Sem vítima 146,425\n203036: 31/12/2022 12:12:09             188         Com vítima 223,520\n           trecho     sentido              lugar_acidente tipo_de_acidente\n     1: BR-116/PR         Sul Autopista Regis Bittencourt Colisão Traseira\n     2: BR-116/PR       Norte Autopista Regis Bittencourt   Saida de Pista\n     3: BR-116/PR         Sul Autopista Regis Bittencourt   Saida de Pista\n     4: BR-101/SC         Sul       Autopista Litoral Sul   Saida de Pista\n     5: BR-101/SC         Sul       Autopista Litoral Sul    Queda de Moto\n    ---                                                                   \n203032: BR-116/SC   Crescente       Autopista Litoral Sul Colisão traseira\n203033: BR-101/SC   Crescente       Autopista Litoral Sul Colisão traseira\n203034: BR-101/SC   Crescente       Autopista Litoral Sul    Queda de moto\n203035: BR-101/SC   Crescente       Autopista Litoral Sul           Choque\n203036: BR-101/SC Decrescente       Autopista Litoral Sul    Queda de moto\n        automovel bicicleta caminhao moto onibus outros tracao_animal\n     1:         2        NA       NA   NA     NA     NA            NA\n     2:         1        NA       NA   NA     NA     NA            NA\n     3:         1        NA       NA   NA     NA     NA            NA\n     4:         1        NA       NA   NA     NA     NA            NA\n     5:        NA        NA       NA    1     NA     NA            NA\n    ---                                                              \n203032:         1         0        0    1      0      0             0\n203033:         2         0        0    0      0      0             0\n203034:         0         0        0    1      0      0             0\n203035:         1         0        0    0      0      0             0\n203036:         0         0        0    1      0      0             0\n        transporte_de_cargas_especiais trator_maquinas utilitarios ilesos\n     1:                             NA              NA          NA      3\n     2:                             NA              NA          NA      3\n     3:                             NA              NA          NA      4\n     4:                             NA              NA          NA      1\n     5:                             NA              NA          NA      0\n    ---                                                                  \n203032:                              0               0           0      1\n203033:                              0               0           0      2\n203034:                              0               0           0      0\n203035:                              0               0           0      0\n203036:                              0               0           0      0\n        levemente_feridos moderadamente_feridos gravemente_feridos mortos\n     1:                NA                    NA                 NA     NA\n     2:                NA                    NA                 NA     NA\n     3:                NA                    NA                 NA     NA\n     4:                NA                    NA                 NA     NA\n     5:                 2                    NA                 NA     NA\n    ---                                                                  \n203032:                 1                     0                  0      0\n203033:                 0                     0                  0      0\n203034:                 1                     0                  0      0\n203035:                 0                     0                  0      0\n203036:                 2                     0                  0      0\n```\n:::\n:::\n\n\nPodemos estar interessados nas autopistas que não são operadas pelas mesmas operadoras. Para isso precisamos definir um operador de *not in*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`%ni%` <- Negate(`%in%`)\n\ndados_filtrados <- car_crash %>%\n  filter(lugar_acidente %ni% autopistas) \ndados_filtrados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              data  horario n_da_ocorrencia           tipo_de_ocorrencia\n     1: 01/01/2010 04:21:00              18                   sem vítima\n     2: 01/01/2010 03:35:00     000024/2010                   sem vítima\n     3: 01/01/2010 07:31:00     000038/2010                   sem vítima\n     4: 01/01/2010 04:57:00     000027/2010                   sem vítima\n     5: 01/01/2010 08:02:00     000042/2010                   sem vítima\n    ---                                                                 \n661521: 31/12/2022 02:10:00              17 Acidente com Danos Materiais\n661522: 31/12/2022 00:08:00               4 Acidente com Danos Materiais\n661523: 31/12/2022 03:28:00              21                   Com vítima\n661524: 31/12/2022 05:05:55              14                   Sem vítima\n661525: 31/12/2022 13:49:33             339 Acidente com Danos Materiais\n             km    trecho     sentido         lugar_acidente tipo_de_acidente\n     1:     167 BR-393/RJ       Norte         Rodovia do Aço       Derrapagem\n     2:      77 BR-290/RS       Norte                Concepa  COLISÃO LATERAL\n     3:      52 BR-116/RS       Norte                Concepa    QUEDA DE MOTO\n     4:      33 BR-290/RS       Norte                Concepa    QUEDA DE MOTO\n     5:      24 BR-290/RS         Sul                Concepa   SAÍDA DE PISTA\n    ---                                                                      \n661521: 636,000 BR-262/MG       Leste               Concebra   Saida de Pista\n661522: 865,000 BR-262/MG       Oeste               Concebra   Saida de Pista\n661523: 180,000  BR-50/MG Decrescente                 ECO050      Capotamento\n661524: 115,100 BR-116/PR Decrescente Autopista Planalto Sul Colisão traseira\n661525: 379,000 BR-262/MG       Leste               Concebra   Saida de Pista\n        automovel bicicleta caminhao moto onibus outros tracao_animal\n     1:         1        NA       NA   NA     NA     NA            NA\n     2:         2         0        0    0      0      0             0\n     3:         0         0        0    1      0      0             0\n     4:         0         0        0    1      0      0             0\n     5:         1         0        0    0      0      0             0\n    ---                                                              \n661521:         1         0        0    0      0      0             0\n661522:         1         0        0    0      0      0             0\n661523:         1         0        0    0      0      0             0\n661524:         2         0        0    0      0      0             0\n661525:         0         0        1    0      0      0             0\n        transporte_de_cargas_especiais trator_maquinas utilitarios ilesos\n     1:                             NA              NA          NA      1\n     2:                              0               0           0      2\n     3:                              0               0           0      1\n     4:                              0               0           0      1\n     5:                              0               0           0      1\n    ---                                                                  \n661521:                              0               0           0      3\n661522:                              0               0           0      1\n661523:                              0               0           0      3\n661524:                              0               0           0      2\n661525:                              0               0           0      1\n        levemente_feridos moderadamente_feridos gravemente_feridos mortos\n     1:                 0                     0                  0      0\n     2:                 0                     0                  0      0\n     3:                 0                     0                  0      0\n     4:                 0                     0                  0      0\n     5:                 0                     0                  0      0\n    ---                                                                  \n661521:                 0                     0                  0      0\n661522:                 0                     0                  0      0\n661523:                 1                     0                  0      0\n661524:                 0                     0                  0      0\n661525:                 0                     0                  0      0\n```\n:::\n:::\n\n\nAlternativamente,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>%\n  filter(!(lugar_acidente %in% autopistas))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              data  horario n_da_ocorrencia           tipo_de_ocorrencia\n     1: 01/01/2010 04:21:00              18                   sem vítima\n     2: 01/01/2010 03:35:00     000024/2010                   sem vítima\n     3: 01/01/2010 07:31:00     000038/2010                   sem vítima\n     4: 01/01/2010 04:57:00     000027/2010                   sem vítima\n     5: 01/01/2010 08:02:00     000042/2010                   sem vítima\n    ---                                                                 \n661521: 31/12/2022 02:10:00              17 Acidente com Danos Materiais\n661522: 31/12/2022 00:08:00               4 Acidente com Danos Materiais\n661523: 31/12/2022 03:28:00              21                   Com vítima\n661524: 31/12/2022 05:05:55              14                   Sem vítima\n661525: 31/12/2022 13:49:33             339 Acidente com Danos Materiais\n             km    trecho     sentido         lugar_acidente tipo_de_acidente\n     1:     167 BR-393/RJ       Norte         Rodovia do Aço       Derrapagem\n     2:      77 BR-290/RS       Norte                Concepa  COLISÃO LATERAL\n     3:      52 BR-116/RS       Norte                Concepa    QUEDA DE MOTO\n     4:      33 BR-290/RS       Norte                Concepa    QUEDA DE MOTO\n     5:      24 BR-290/RS         Sul                Concepa   SAÍDA DE PISTA\n    ---                                                                      \n661521: 636,000 BR-262/MG       Leste               Concebra   Saida de Pista\n661522: 865,000 BR-262/MG       Oeste               Concebra   Saida de Pista\n661523: 180,000  BR-50/MG Decrescente                 ECO050      Capotamento\n661524: 115,100 BR-116/PR Decrescente Autopista Planalto Sul Colisão traseira\n661525: 379,000 BR-262/MG       Leste               Concebra   Saida de Pista\n        automovel bicicleta caminhao moto onibus outros tracao_animal\n     1:         1        NA       NA   NA     NA     NA            NA\n     2:         2         0        0    0      0      0             0\n     3:         0         0        0    1      0      0             0\n     4:         0         0        0    1      0      0             0\n     5:         1         0        0    0      0      0             0\n    ---                                                              \n661521:         1         0        0    0      0      0             0\n661522:         1         0        0    0      0      0             0\n661523:         1         0        0    0      0      0             0\n661524:         2         0        0    0      0      0             0\n661525:         0         0        1    0      0      0             0\n        transporte_de_cargas_especiais trator_maquinas utilitarios ilesos\n     1:                             NA              NA          NA      1\n     2:                              0               0           0      2\n     3:                              0               0           0      1\n     4:                              0               0           0      1\n     5:                              0               0           0      1\n    ---                                                                  \n661521:                              0               0           0      3\n661522:                              0               0           0      1\n661523:                              0               0           0      3\n661524:                              0               0           0      2\n661525:                              0               0           0      1\n        levemente_feridos moderadamente_feridos gravemente_feridos mortos\n     1:                 0                     0                  0      0\n     2:                 0                     0                  0      0\n     3:                 0                     0                  0      0\n     4:                 0                     0                  0      0\n     5:                 0                     0                  0      0\n    ---                                                                  \n661521:                 0                     0                  0      0\n661522:                 0                     0                  0      0\n661523:                 1                     0                  0      0\n661524:                 0                     0                  0      0\n661525:                 0                     0                  0      0\n```\n:::\n:::\n\n\nOutras vezes, podemos utilizar o operador `%like%` que busca padrões. Por exemplo, podemos estar interessados em buscar todos acidentes que ocorreram com vítimas, e no campo `tipo_de_ocorrencia` podemos simplesmente buscar por:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  filter(tipo_de_ocorrencia %like% \"com vítima\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              data  horario n_da_ocorrencia               tipo_de_ocorrencia\n     1: 01/01/2010 15:53:00              48                       com vítima\n     2: 01/01/2010 16:30:00             377                       com vítima\n     3: 01/01/2010 01:06:00               2                       com vítima\n     4: 01/01/2010 11:25:00             102                       com vítima\n     5: 01/01/2010 12:41:00             142                       com vítima\n    ---                                                                     \n219209: 31/12/2022 10:28:00             211              Acidente com vítima\n219210: 31/12/2022 07:53:44              26 ac03 - Acidente com vítima ilesa\n219211: 31/12/2022 10:18:00             206              Acidente com vítima\n219212: 31/12/2022 01:53:24              10 ac03 - Acidente com vítima ilesa\n219213: 31/12/2022 07:53:44              26 ac03 - Acidente com vítima ilesa\n             km    trecho     sentido              lugar_acidente\n     1:   119,5 BR-116/PR         Sul      Autopista Planalto Sul\n     2:      35 BR-101/SC         Sul       Autopista Litoral Sul\n     3:     114 BR-040/RJ         Sul                      Concer\n     4:      64 BR-381/SP         Sul       Autopista Fernão Dias\n     5:     273 BR-116/PR       Norte Autopista Regis Bittencourt\n    ---                                                          \n219209:     144 BR-116/SP   Pista Sul                       RIOSP\n219210: 118,572 BR-116/RJ         Sul                 Ecoriominas\n219211:      44 BR-101/SP Pista Norte                       RIOSP\n219212:    39,9 BR-116/RJ         Sul                 Ecoriominas\n219213: 118,572 BR-116/RJ         Sul                 Ecoriominas\n            tipo_de_acidente automovel bicicleta caminhao moto onibus outros\n     1:  Colisão Transversal         2        NA       NA   NA     NA     NA\n     2:        Queda de Moto        NA        NA       NA    1     NA     NA\n     3: Choque - Objeto Fixo         1        NA       NA   NA     NA     NA\n     4:          Capotamento         1        NA       NA   NA     NA     NA\n     5:      Colisão Lateral        NA        NA       NA    1      1     NA\n    ---                                                                     \n219209:        Queda de moto         0         0        0    1      0      0\n219210:       Saida de Pista         1        NA       NA   NA     NA     NA\n219211:        Engavetamento         3         0        0    0      0      0\n219212:          Capotamento         1        NA       NA   NA     NA     NA\n219213:       Saida de Pista         1        NA       NA   NA     NA     NA\n        tracao_animal transporte_de_cargas_especiais trator_maquinas\n     1:            NA                             NA              NA\n     2:            NA                             NA              NA\n     3:            NA                             NA              NA\n     4:            NA                             NA              NA\n     5:            NA                             NA              NA\n    ---                                                             \n219209:             0                             NA               0\n219210:            NA                             NA              NA\n219211:             0                             NA               0\n219212:            NA                             NA              NA\n219213:            NA                             NA              NA\n        utilitarios ilesos levemente_feridos moderadamente_feridos\n     1:          NA      4                 5                    NA\n     2:          NA      0                 2                    NA\n     3:          NA      0                 2                    NA\n     4:          NA      0                 1                    NA\n     5:          NA      2                NA                     1\n    ---                                                           \n219209:           0      0                 1                     0\n219210:          NA      1                NA                    NA\n219211:           0     10                 1                     0\n219212:          NA      1                NA                    NA\n219213:          NA      1                NA                    NA\n        gravemente_feridos mortos\n     1:                 NA     NA\n     2:                 NA     NA\n     3:                 NA     NA\n     4:                 NA     NA\n     5:                 NA     NA\n    ---                          \n219209:                  0      0\n219210:                 NA     NA\n219211:                  0      0\n219212:                 NA     NA\n219213:                 NA     NA\n```\n:::\n:::\n\n\nAlgumas vezes temos apenas vários padrões de texto que gostaríamos de buscar. Para isso, a função `grepl()` permite filtrar com base em padrões de texto.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash %>% \n  filter(grepl(\"ilesa|fatal\", tipo_de_ocorrencia))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            data  horario n_da_ocorrencia               tipo_de_ocorrencia\n   1: 01/01/2021 04:46:54              23 ac03 - Acidente com vítima ilesa\n   2: 01/01/2021 14:00:09              83 ac03 - Acidente com vítima ilesa\n   3: 01/01/2023 12:34:00              58 ac03 - Acidente com vítima ilesa\n   4: 01/01/2023 16:39:20              90 ac03 - Acidente com vítima ilesa\n   5: 01/01/2023 17:19:19              95 ac03 - Acidente com vítima ilesa\n  ---                                                                     \n2001: 31/12/2022 01:53:24              10 ac03 - Acidente com vítima ilesa\n2002: 31/12/2022 04:50:18              17 ac03 - Acidente com vítima ilesa\n2003: 31/12/2022 07:53:44              26 ac03 - Acidente com vítima ilesa\n2004: 31/12/2022 01:53:24              10 ac03 - Acidente com vítima ilesa\n2005: 31/12/2022 07:53:44              26 ac03 - Acidente com vítima ilesa\n           km    trecho sentido lugar_acidente                 tipo_de_acidente\n   1:   163,2 BR-050/GO   Norte         ECO050          Atropelamento de Animal\n   2:    37,8 BR-050/MG     Sul         ECO050        Choque - Defensa metálica\n   3:  17,781 BR-116/RJ     Sul    Ecoriominas                  Choque - Arvore\n   4:      42 BR-116/RJ     Sul    Ecoriominas Colisão lateral no mesmo sentido\n   5:     109 BR-116/RJ   Norte    Ecoriominas Colisão lateral no mesmo sentido\n  ---                                                                          \n2001:    39,9 BR-116/RJ     Sul    Ecoriominas                      Capotamento\n2002:    54,3 BR-493/RJ   Norte    Ecoriominas                   Choque - Poste\n2003: 118,572 BR-116/RJ     Sul    Ecoriominas                   Saida de Pista\n2004:    39,9 BR-116/RJ     Sul    Ecoriominas                      Capotamento\n2005: 118,572 BR-116/RJ     Sul    Ecoriominas                   Saida de Pista\n      automovel bicicleta caminhao moto onibus outros tracao_animal\n   1:         1        NA       NA   NA     NA     NA            NA\n   2:         1        NA       NA   NA     NA     NA            NA\n   3:        NA        NA        1   NA     NA     NA            NA\n   4:         2        NA       NA   NA     NA     NA            NA\n   5:         1        NA       NA   NA     NA      1            NA\n  ---                                                              \n2001:         1        NA       NA   NA     NA     NA            NA\n2002:        NA        NA        1   NA     NA     NA            NA\n2003:         1        NA       NA   NA     NA     NA            NA\n2004:         1        NA       NA   NA     NA     NA            NA\n2005:         1        NA       NA   NA     NA     NA            NA\n      transporte_de_cargas_especiais trator_maquinas utilitarios ilesos\n   1:                             NA              NA          NA      1\n   2:                             NA              NA          NA      2\n   3:                             NA              NA          NA      1\n   4:                             NA              NA          NA      4\n   5:                             NA              NA          NA      2\n  ---                                                                  \n2001:                             NA              NA          NA      1\n2002:                             NA              NA          NA      1\n2003:                             NA              NA          NA      1\n2004:                             NA              NA          NA      1\n2005:                             NA              NA          NA      1\n      levemente_feridos moderadamente_feridos gravemente_feridos mortos\n   1:                NA                    NA                 NA     NA\n   2:                NA                    NA                 NA     NA\n   3:                NA                    NA                 NA     NA\n   4:                NA                    NA                 NA     NA\n   5:                NA                    NA                 NA     NA\n  ---                                                                  \n2001:                NA                    NA                 NA     NA\n2002:                NA                    NA                 NA     NA\n2003:                NA                    NA                 NA     NA\n2004:                NA                    NA                 NA     NA\n2005:                NA                    NA                 NA     NA\n```\n:::\n:::\n\n\n### 4.2.3 Resumo de informações\nNo tidyverse, as funções `summarise()` e `group_by()` são amplamente utilizadas para resumir informações e realizar cálculos agregados em conjuntos de dados. Elas desempenham um papel crucial na análise exploratória e na obtenção de insights significativos a partir dos dados. Vamos explorar como essas funções funcionam e como usá-las para resumir informações de maneira eficaz.\n\n#### 4.2.3.1 Função `summarise()`\nA função `summarise()` é utilizada para calcular estatísticas resumidas para uma coluna ou um conjunto de colunas. Ela permite calcular médias, somas, desvios padrão, mínimos, máximos e outras estatísticas relevantes.\n\nEstamos interessados em uma tabela descritiva para a variável `levemente_feridos`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabela <- car_crash %>% \n    summarise(n = n(), \n              f_r = n()/nrow(car_crash), \n              f_per = n()/nrow(car_crash) * 100, \n              media = mean(levemente_feridos, na.rm = T), \n              Q1 = quantile(levemente_feridos, 0.25, type = 5, na.rm = T), \n              Q2 = quantile(levemente_feridos, 0.5, type = 5, na.rm = T), \n              Q3 = quantile(levemente_feridos, 0.75, type = 5, na.rm = T), \n              var = var(levemente_feridos, na.rm = T), \n              sd  = sd(levemente_feridos, na.rm = T), \n              min = min(levemente_feridos, na.rm = T), \n              max = max(levemente_feridos, na.rm = T)) \n\ntabela\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       n f_r f_per     media Q1 Q2 Q3      var       sd min max\n1 864561   1   100 0.6814294  0  0  1 1.009796 1.004886   0  51\n```\n:::\n:::\n\n\n#### 4.2.3.2 Agrupamento de dados\nA função `group_by()` é usada para agrupar o conjunto de dados por uma ou mais colunas. Isso cria um contexto em que a função `summarise()` pode calcular estatísticas específicas para cada grupo.\n\nEstamos interessados em uma tabela descritiva para a variável `levemente_feridos` por `tipo_de_ocorrencia`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabela <- car_crash %>% \n    summarise(n = n(), \n              f_r = n()/nrow(car_crash), \n              f_per = n()/nrow(car_crash) * 100, \n              media = mean(levemente_feridos, na.rm = T), \n              Q1 = quantile(levemente_feridos, 0.25, type = 5, na.rm = T), \n              Q2 = quantile(levemente_feridos, 0.5, type = 5, na.rm = T), \n              Q3 = quantile(levemente_feridos, 0.75, type = 5, na.rm = T), \n              var = var(levemente_feridos, na.rm = T), \n              sd  = sd(levemente_feridos, na.rm = T), \n              min = min(levemente_feridos, na.rm = T), \n              max = max(levemente_feridos, na.rm = T)) \n\ntabela\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       n f_r f_per     media Q1 Q2 Q3      var       sd min max\n1 864561   1   100 0.6814294  0  0  1 1.009796 1.004886   0  51\n```\n:::\n:::\n\n\n## 4.3 Exercício\n1. Utilizando o banco de dados `starwars` faça o que se pede:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\ndata(starwars)\nhead(starwars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n1 Luke Sky…    172    77 blond      fair       blue            19   male  mascu…\n2 C-3PO        167    75 <NA>       gold       yellow         112   none  mascu…\n3 R2-D2         96    32 <NA>       white, bl… red             33   none  mascu…\n4 Darth Va…    202   136 none       white      yellow          41.9 male  mascu…\n5 Leia Org…    150    49 brown      light      brown           19   fema… femin…\n6 Owen Lars    178   120 brown, gr… light      blue            52   male  mascu…\n# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,\n#   vehicles <list>, starships <list>\n```\n:::\n:::\n\n\na) Qual é o número total de espécies únicas presentes? Qual a frequência de indivíduos por espécie?\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcule o número total de espécies únicas presentes\nnum_species <- starwars %>% \n  distinct(species) %>% \n  nrow()\n\n# Calcule a frequência de indivíduos por espécie\nspecies_frequency <- starwars %>% \n  group_by(species) %>% \n  summarise(frequency = n())\n\n# Exiba os resultados\nnum_species  # Número total de espécies únicas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 38\n```\n:::\n\n```{.r .cell-code}\nspecies_frequency  # Frequência de indivíduos por espécie\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 38 × 2\n   species   frequency\n   <chr>         <int>\n 1 Aleena            1\n 2 Besalisk          1\n 3 Cerean            1\n 4 Chagrian          1\n 5 Clawdite          1\n 6 Droid             6\n 7 Dug               1\n 8 Ewok              1\n 9 Geonosian         1\n10 Gungan            3\n# ℹ 28 more rows\n```\n:::\n:::\n\n\nb) Calcule a altura média de personagens masculinos e femininos.\n\n::: {.cell}\n\n```{.r .cell-code}\nheight_gender <- starwars %>%\n  na.omit(gender) %>%\n  group_by(gender) %>%\n  summarise(altura_media = mean(height, na.rm = T))\n\nheight_gender\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  gender    altura_media\n  <chr>            <dbl>\n1 feminine          166.\n2 masculine         181.\n```\n:::\n:::\n\n\nc) Qual é a média de idade dos personagens de cada espécie para personagens masculinos?\n\n::: {.cell}\n\n```{.r .cell-code}\nmedia_idade <- starwars %>%\n  filter(gender == \"masculine\") %>%\n  group_by(species) %>%\n  summarise(media_idade = mean(birth_year, na.rm = TRUE))\n\nmedia_idade\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 33 × 2\n   species   media_idade\n   <chr>           <dbl>\n 1 Aleena          NaN  \n 2 Besalisk        NaN  \n 3 Cerean           92  \n 4 Chagrian        NaN  \n 5 Droid            53.3\n 6 Dug             NaN  \n 7 Ewok              8  \n 8 Geonosian       NaN  \n 9 Gungan           52  \n10 Human            55.2\n# ℹ 23 more rows\n```\n:::\n:::\n\n\nd) Para cada espécie presente na base de dados, identifique o personagem mais velho e sua idade correspondente.\n\n::: {.cell}\n\n```{.r .cell-code}\nold_character <- starwars %>%\n  group_by(species) %>%\n  filter(!is.na(birth_year)) %>% # sem este filtro, especies com valores ausentes não vão aparecer\n  filter(birth_year == max(birth_year)) %>%\n  summarise(personagem = name,\n            idade = max(birth_year))\n\nold_character\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 3\n   species        personagem            idade\n   <chr>          <chr>                 <dbl>\n 1 Cerean         Ki-Adi-Mundi             92\n 2 Droid          C-3PO                   112\n 3 Ewok           Wicket Systri Warrick     8\n 4 Gungan         Jar Jar Binks            52\n 5 Human          Dooku                   102\n 6 Hutt           Jabba Desilijic Tiure   600\n 7 Kel Dor        Plo Koon                 22\n 8 Mirialan       Luminara Unduli          58\n 9 Mon Calamari   Ackbar                   41\n10 Rodian         Greedo                   44\n11 Trandoshan     Bossk                    53\n12 Twi'lek        Ayla Secura              48\n13 Wookiee        Chewbacca               200\n14 Yoda's species Yoda                    896\n15 Zabrak         Darth Maul               54\n16 <NA>           Quarsh Panaka            62\n```\n:::\n:::\n\n\n## 4.4 Manipulação de Data no R\nA transformação de strings em datas e a manipulação de datas são tarefas comuns em análise de dados. No R, existem várias funções e pacotes disponíveis para facilitar essas operações. Vamos explorar como realizar essas tarefas usando as funcionalidades básicas do R.\n\n### 4.4.1 Transformando Strings em Datas\nPara transformar strings em datas, podemos utilizar a função `as.Date()`. Por exemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# String representando uma data\ndata_string <- \"2023-08-21\"\n\n# Transformando a string em data\ndata <- as.Date(data_string)\n\n# Exibindo a data\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21\"\n```\n:::\n:::\n\n\nTambém podemos especificar o formato da string de data usando o argumento `format`. Por exemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_string <- \"21/08/2023\"\n\ndata <- as.Date(data_string, \n                format = \"%d/%m/%Y\")\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21\"\n```\n:::\n:::\n\n\n### 4.4.2 Manipulação de Datas\nApós transformar strings em datas, podemos realizar várias operações de manipulação de datas. Algumas das operações mais comuns incluem:\n\n* Adição e subtração de dias, semanas, meses ou anos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- as.Date(\"2023-08-21\")\ndata2 <- data + 7  # Adicionando 7 dias\ndata3 <- data - 1  # Subtraindo 1 dia\n```\n:::\n\n\n* Comparação de datas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1 <- as.Date(\"2023-08-21\")\ndata2 <- as.Date(\"2023-08-15\")\ndata1 > data2  # Verifica se data1 é posterior a data2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n* Formatação de datas para strings:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- as.Date(\"2023-08-21\")\ndata_formatada <- format(data, \"%d/%m/%Y\")\n```\n:::\n\n\n* Extração de componentes de data (ano, mês, dia):\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- as.Date(\"2023-08-21\")\nano <- format(data, \"%Y\")\nmes <- format(data, \"%m\")\ndia <- format(data, \"%d\")\n```\n:::\n\n\n* Cálculo de diferenças entre datas:\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1 <- as.Date(\"2023-08-21\")\ndata2 <- as.Date(\"2023-08-15\")\ndiferenca <- difftime(data1, data2, units = \"days\")  # Diferença em dias\n```\n:::\n\n\n### 4.4.3 Lubridate: Facilitando a Manipulação de Datas no R\n\nLidar com datas no R pode ser uma tarefa desafiadora, especialmente quando se precisa realizar operações complexas ou extrair informações específicas das datas. O pacote `lubridate` foi desenvolvido para simplificar a manipulação de datas, tornando as tarefas relacionadas a datas mais fáceis e intuitivas. Vamos explorar algumas das principais funcionalidades do `lubridate` em mais detalhes, com exemplos práticos:\n\n#### 4.4.3.1 Instalação e Carregamento do Lubridate\nAntes de usar o `lubridate`, é necessário instalá-lo e carregá-lo no R. Para isso, utilize o comando `install.packages(\"lubridate\")` para a instalação e `library(lubridate)` para o carregamento do pacote. Essas etapas devem ser executadas apenas uma vez.\n\n#### 4.4.3.2 Criando Datas\nO `lubridate` torna a criação de datas simples e flexível. Podemos criar datas usando diferentes funções, dependendo do formato dos seus dados. Além da já mencionada `ymd()` para datas no formato “ano-mês-dia,” também podemos utilizar:\n\n* `mdy()` para datas no formato “mês-dia-ano.”\n\n* `dmy()` para datas no formato “dia-mês-ano.”\n\nEssas funções ajudam a evitar confusões em relação ao formato das datas, tornando o processo de entrada de dados mais seguro. Veja um exemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(lubridate)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: lubridate\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'lubridate'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:data.table':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_ymd <- ymd(\"2023-08-21\")\ndata_mdy <- mdy(\"08-21-2023\")\ndata_dmy <- dmy(\"21-08-2023\")\n\nprint(data_ymd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(data_mdy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(data_dmy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21\"\n```\n:::\n:::\n\n\n#### 4.4.3.3 Operações com Datas\nOperações com datas, como adição e subtração de dias, semanas, meses ou anos, são realizadas de forma mais clara e intuitiva no `lubridate`. O pacote fornece funções específicas para isso, como `days()`, `weeks()`, `months()`, e `years()`. Isso permite que executemos operações como:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- ymd(\"2023-08-21\")\ndata_nova <- data + days(7)  # Adiciona 7 dias\ndata_anterior <- data - months(2)  # Subtrai 2 meses\n\nprint(data_nova)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-28\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(data_anterior)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-06-21\"\n```\n:::\n:::\n\n\nEssa sintaxe simplificada torna as operações com datas mais legíveis e menos propensas a erros.\n\n#### 4.4.3.4 Extraindo Informações de Datas\nO `lubridate` permite extrair facilmente informações de datas. Com funções como `year()`, `month()`, e `day()`, você pode obter o ano, mês ou dia de uma data específica. Além disso, é possível extrair informações mais detalhadas, como hora, minuto, e segundo, caso necessário. Isso é particularmente útil ao lidar com séries temporais ou análises de eventos temporais específicos. Veja exemplos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- ymd_hms(\"2023-08-21 15:30:45\")\nano <- year(data)\nmes <- month(data)\ndia <- day(data)\nhora <- hour(data)\nminuto <- minute(data)\nsegundo <- second(data)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(ano)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2023\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(mes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(dia)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(hora)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(minuto)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 30\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(segundo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45\n```\n:::\n:::\n\n\n#### 4.4.3.5 Funções de Resumo de Datas\nO `lubridate` oferece funções que auxiliam na análise e resumo de datas. Podemos calcular a diferença entre duas datas com facilidade, obtendo o resultado em dias, semanas, meses ou anos. Isso é útil em cenários em que é preciso medir a duração entre eventos ou calcular intervalos de tempo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1 <- ymd(\"2023-08-21\")\ndata2 <- ymd(\"2023-08-15\")\ndiferenca_em_dias <- as.numeric(data2 - data1)\ndiferenca_em_semanas <- as.numeric(weeks(data2 - data1))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(diferenca_em_dias)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(diferenca_em_semanas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3628800\n```\n:::\n:::\n\n\n#### 4.4.3.6 Lidar com Fusos Horários\nPara situações que envolvem fusos horários, o `lubridate` facilita a manipulação, permitindo a converção de datas entre fusos e calcule diferenças de tempo em fusos diferentes. Isso é especialmente valioso em análises que abrangem regiões geográficas distintas ou quando é necessário considerar fusos horários em análises de eventos globais.\n\n* Converter uma Data para um Fuso Horário Específico:\nImagine que temos uma data em um fuso horário específico e desejamos convertê-la para outro fuso horário. O `lubridate` facilita essa tarefa usando a função `with_tz()`. Veja um exemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data original no fuso horário de Nova Iorque\ndata_ny <- ymd_hms(\"2023-08-21 12:00:00\", tz = \"America/New_York\")\n\n# Converter para o fuso horário de Londres\ndata_london <- with_tz(data_ny, tz = \"Europe/London\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(data_ny)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21 12:00:00 EDT\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(data_london)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21 17:00:00 BST\"\n```\n:::\n:::\n\n\nNeste exemplo, convertemos uma data de Nova Iorque para Londres.\n\n* **Calcular a Diferença de Tempo entre Datas em Fusos Horários Diferentes**:\n\nCalcular a diferença de tempo entre duas datas em fusos horários diferentes pode ser útil para determinar a sincronização de eventos em locais geograficamente distintos. O `lubridate` permite isso com facilidade:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Duas datas em fusos horários diferentes\ndata_ny <- ymd_hms(\"2023-08-21 12:00:00\", tz = \"America/New_York\")\ndata_london <- ymd_hms(\"2023-08-21 17:00:00\", tz = \"Europe/London\")\n\n# Calcular a diferença de tempo em horas\ndiferenca_horas <- as.numeric(data_london - data_ny)\n\nprint(diferenca_horas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n* **Trabalhar com Fusos Horários em Data Frames**:\nEm muitos casos, você pode ter um conjunto de dados com datas em diferentes fusos horários. O `lubridate` permite a manipulação desses dados em um Data Frame de forma eficiente. Suponha que temos um Data Frame chamado `dados` com datas em diferentes fusos horários:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados <- data.frame(\n  nome = c(\"Evento 1\", \"Evento 2\"),\n  data = c(\n    ymd_hms(\"2023-08-21 12:00:00\", tz = \"America/New_York\"),\n    ymd_hms(\"2023-08-21 17:00:00\", tz = \"Europe/London\")\n  )\n)\n\n# Converter todas as datas para um fuso horário comum, por exemplo, UTC\ndados$data_utc <- with_tz(dados$data, tz = \"UTC\")\n\nprint(dados)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      nome                data            data_utc\n1 Evento 1 2023-08-21 12:00:00 2023-08-21 16:00:00\n2 Evento 2 2023-08-21 12:00:00 2023-08-21 16:00:00\n```\n:::\n:::\n\n\nNeste exemplo, convertemos todas as datas no Data Frame para o fuso horário UTC, criando uma nova coluna chamada `data_utc`.\n\nLidar com fusos horários em análises de dados é fundamental para garantir que as informações temporais sejam precisas e consistentes, especialmente em cenários globais ou quando eventos ocorrem em locais diferentes ao redor do mundo. O pacote `lubridate` no R simplifica significativamente essa tarefa, tornando a manipulação de datas com fusos horários uma tarefa mais clara e eficiente.\n\n## 4.5 Exercícios\n\n1. Utilizando o banco de dados `car_crash`:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Carregue as bibliotecas\nlibrary(dplyr)\nlibrary(lubridate)\n\ncar_crash <- fread(\"./datasets/Brazil Total highway crashes 2010 - 2023.csv.gz\")\n\nhead(car_crash)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         data  horario n_da_ocorrencia tipo_de_ocorrencia    km    trecho\n1: 01/01/2010 04:21:00              18         sem vítima   167 BR-393/RJ\n2: 01/01/2010 02:13:00              20         sem vítima 269,5 BR-116/PR\n3: 01/01/2010 03:35:00     000024/2010         sem vítima    77 BR-290/RS\n4: 01/01/2010 07:31:00     000038/2010         sem vítima    52 BR-116/RS\n5: 01/01/2010 04:57:00     000027/2010         sem vítima    33 BR-290/RS\n6: 01/01/2010 08:02:00     000042/2010         sem vítima    24 BR-290/RS\n   sentido              lugar_acidente tipo_de_acidente automovel bicicleta\n1:   Norte              Rodovia do Aço       Derrapagem         1        NA\n2:     Sul Autopista Regis Bittencourt Colisão Traseira         2        NA\n3:   Norte                     Concepa  COLISÃO LATERAL         2         0\n4:   Norte                     Concepa    QUEDA DE MOTO         0         0\n5:   Norte                     Concepa    QUEDA DE MOTO         0         0\n6:     Sul                     Concepa   SAÍDA DE PISTA         1         0\n   caminhao moto onibus outros tracao_animal transporte_de_cargas_especiais\n1:       NA   NA     NA     NA            NA                             NA\n2:       NA   NA     NA     NA            NA                             NA\n3:        0    0      0      0             0                              0\n4:        0    1      0      0             0                              0\n5:        0    1      0      0             0                              0\n6:        0    0      0      0             0                              0\n   trator_maquinas utilitarios ilesos levemente_feridos moderadamente_feridos\n1:              NA          NA      1                 0                     0\n2:              NA          NA      3                NA                    NA\n3:               0           0      2                 0                     0\n4:               0           0      1                 0                     0\n5:               0           0      1                 0                     0\n6:               0           0      1                 0                     0\n   gravemente_feridos mortos\n1:                  0      0\n2:                 NA     NA\n3:                  0      0\n4:                  0      0\n5:                  0      0\n6:                  0      0\n```\n:::\n:::\n\n\n\na) formate a coluna data em uma `data` (dd-mm-yyyy)\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash$data_formatada <- as.Date(car_crash$data,\n                                    format = \"%d/%m/%Y\")\ncar_crash %>% \n  select(data, data_formatada) %>% \n  distinct(data, .keep_all = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            data data_formatada\n   1: 01/01/2010     2010-01-01\n   2: 01/01/2011     2011-01-01\n   3: 01/01/2012     2012-01-01\n   4: 01/01/2013     2013-01-01\n   5: 01/01/2014     2014-01-01\n  ---                          \n4947: 31/12/2018     2018-12-31\n4948: 31/12/2019     2019-12-31\n4949: 31/12/2020     2020-12-31\n4950: 31/12/2021     2021-12-31\n4951: 31/12/2022     2022-12-31\n```\n:::\n:::\n\n\nb) formate a coluna horario para o `horário` do acidente (hh:mm:ss)\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash$horario_acidente <- format(strptime(car_crash$horario, format = \"%H:%M:%S\"), \"%H:%M:%S\")\n\n\ncar_crash %>% \n  select(horario, horario_acidente) %>% \n  distinct(horario, .keep_all = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        horario horario_acidente\n    1: 04:21:00         04:21:00\n    2: 02:13:00         02:13:00\n    3: 03:35:00         03:35:00\n    4: 07:31:00         07:31:00\n    5: 04:57:00         04:57:00\n   ---                          \n44265: 23:23:36         23:23:36\n44266: 21:41:52         21:41:52\n44267: 19:26:09         19:26:09\n44268: 05:05:55         05:05:55\n44269: 12:12:09         12:12:09\n```\n:::\n:::\n\n\nc) Qual o mês com maior quantidade de acidentes?\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash$mes <- month(car_crash$data_formatada)\n\nquestao_c <- car_crash %>%\n  group_by(mes) %>%\n  summarise(n = n()) %>%\n  arrange(desc(n))\n\nquestao_c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 2\n     mes     n\n   <dbl> <int>\n 1    12 85308\n 2     1 82507\n 3    10 74716\n 4     6 72276\n 5    11 71677\n 6     3 70696\n 7     2 68783\n 8     5 68626\n 9     9 68586\n10     7 68392\n11     8 66596\n12     4 66398\n```\n:::\n:::\n\n\nd) Qual ano ocorreram mais acidentes?\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash$ano <- year(car_crash$data_formatada)\n\nquestao_d <- car_crash %>%\n  group_by(ano) %>%\n  summarise(n = n()) %>%\n  arrange(desc(n))\n\nquestao_d\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 14 × 2\n     ano     n\n   <dbl> <int>\n 1  2015 74458\n 2  2017 70107\n 3  2016 70104\n 4  2014 67816\n 5  2019 64853\n 6  2018 63970\n 7  2020 62632\n 8  2021 62498\n 9  2012 61090\n10  2013 60953\n11  2011 60455\n12  2022 56838\n13  2010 54837\n14  2023 33950\n```\n:::\n:::\n\n\ne) Qual horário acontecem menos acidentes?\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash$hora <- format(strptime(car_crash$horario, format = \"%H:%M\"), \"%H:%M\")\n\nquestao_e <- car_crash %>%\n  group_by(hora) %>%\n  summarise(n = n()) %>%\n  arrange(n)\n\nquestao_e\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,440 × 2\n   hora      n\n   <chr> <int>\n 1 02:39   219\n 2 01:56   220\n 3 02:58   221\n 4 03:04   221\n 5 02:37   222\n 6 02:43   227\n 7 02:01   229\n 8 02:32   229\n 9 03:21   229\n10 03:13   230\n# ℹ 1,430 more rows\n```\n:::\n:::\n\n\nf) Qual a média, desvio padrão, mediana, Q1 e Q3 para a quantidade de indivíduos classificados como levemente feridos por mês/ano?\n\n::: {.cell}\n\n```{.r .cell-code}\ncar_crash$mes <- sprintf(\"%02d\", as.integer(car_crash$mes))\ncar_crash$`mes/ano` <- paste(car_crash$ano, car_crash$mes, sep = \"/\")\n\nquestao_f <- car_crash %>% \n  filter(!is.na(levemente_feridos)) %>%\n  group_by(`mes/ano`) %>%\n  summarise(n = n(),\n            media = mean(levemente_feridos, na.rm = T), \n            Q1 = quantile(levemente_feridos, 0.25, type = 5, na.rm = T), \n            mediana = quantile(levemente_feridos, 0.5, type = 5, na.rm = T), \n            Q3 = quantile(levemente_feridos, 0.75, type = 5, na.rm = T),\n            min = min(levemente_feridos),\n            max = max(levemente_feridos),\n            sd  = sd(levemente_feridos, na.rm = T)) \n\nquestao_f\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 163 × 9\n   `mes/ano`     n media    Q1 mediana    Q3   min   max    sd\n   <chr>     <int> <dbl> <int>   <int> <int> <int> <int> <dbl>\n 1 2010/01    1880 0.809     0       1     1     0    41 1.42 \n 2 2010/02    1676 0.816     0       1     1     0    30 1.29 \n 3 2010/03    1844 0.741     0       1     1     0    26 1.12 \n 4 2010/04    1842 0.840     0       1     1     0     7 1.00 \n 5 2010/05    2044 0.776     0       1     1     0    19 1.04 \n 6 2010/06    1777 0.757     0       1     1     0    12 0.992\n 7 2010/07    1929 0.802     0       1     1     0    21 1.25 \n 8 2010/08    1776 0.819     0       1     1     0    51 1.52 \n 9 2010/09    2119 0.748     0       1     1     0     9 0.977\n10 2010/10    2030 0.807     0       1     1     0    39 1.29 \n# ℹ 153 more rows\n```\n:::\n:::\n\n\ng) Quantos acidentes com vítimas fatais aconteceram, por mês/ano, em mediana entre as 6:00am e 11:59am.\n\n::: {.cell}\n\n```{.r .cell-code}\nquestao_g <- car_crash %>% \n  filter(tipo_de_ocorrencia %like% \"com vítima\" & between(hora, \"06:00\", \"11:59\")) %>%\n  group_by(`mes/ano`) %>%\n  summarise(n = n()) \n\nquestao_g\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 159 × 2\n   `mes/ano`     n\n   <chr>     <int>\n 1 2010/01     308\n 2 2010/02     325\n 3 2010/03     333\n 4 2010/04     380\n 5 2010/05     443\n 6 2010/06     381\n 7 2010/07     406\n 8 2010/08     348\n 9 2010/09     426\n10 2010/10     417\n# ℹ 149 more rows\n```\n:::\n:::\n\n\n## 4.6 Junção de dados\nÉ raro que uma análise de dados envolva apenas uma única fonte de dados. Normalmente, você possui vários `data.frames` e precisa uni-los para realizar as análises que lhe interessam.\n\n### 4.6.1 Dados\nPara a aula de hoje, utilizaremos o pacote `nycflights13`, o qual contém dados relacionados a voos na cidade de Nova York.\n\n### 4.6.2 Chaves Primárias e Chaves Estrangeiras\nPara compreender os principais tipos de junções de banco de dados, é fundamental entender como duas tabelas podem ser conectadas por meio de um par de chaves, dentro de cada tabela. Vamos estudar brevemente sobre os dois tipos principais de chaves, para isso, vamos utilizar os conjuntos de dados do pacote `nycflights13`. Esse pacote apresenta cinco tabelas com informações distintas acerca de vôos em New York.\n\n#### 4.6.2.1 Chaves primárias e estrangeiras\nToda junção envolve um par de chaves: *uma chave primária e uma chave estrangeira*. **Uma chave primária é uma variável ou conjunto de variáveis que identifica cada observação de forma única**. Quando mais de uma variável é necessária, a chave é chamada de chave composta. Por exemplo, no `nycfights13`:\n\n* A tabela `airlines` registra dois dados sobre cada companhia aérea: seu código de operadora e seu nome completo. Você pode identificar uma companhia aérea pelo seu código de operadora de duas letras, tornando o código de operadora (`carrier`) a chave primária (*primary key*).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(nycflights13)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: nycflights13\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nairlines\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 2\n   carrier name                       \n   <chr>   <chr>                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n11 OO      SkyWest Airlines Inc.      \n12 UA      United Air Lines Inc.      \n13 US      US Airways Inc.            \n14 VX      Virgin America             \n15 WN      Southwest Airlines Co.     \n16 YV      Mesa Airlines Inc.         \n```\n:::\n:::\n\n\n* A tabela `airports`, por sua vez, registra dados sobre cada aeroporto. Podemos identificar cada aeroporto pelo seu código de aeroporto de três letras, tornando o código `FAA` a chave primária.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairports\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,458 × 8\n   faa   name                             lat    lon   alt    tz dst   tzone    \n   <chr> <chr>                          <dbl>  <dbl> <dbl> <dbl> <chr> <chr>    \n 1 04G   Lansdowne Airport               41.1  -80.6  1044    -5 A     America/…\n 2 06A   Moton Field Municipal Airport   32.5  -85.7   264    -6 A     America/…\n 3 06C   Schaumburg Regional             42.0  -88.1   801    -6 A     America/…\n 4 06N   Randall Airport                 41.4  -74.4   523    -5 A     America/…\n 5 09J   Jekyll Island Airport           31.1  -81.4    11    -5 A     America/…\n 6 0A9   Elizabethton Municipal Airport  36.4  -82.2  1593    -5 A     America/…\n 7 0G6   Williams County Airport         41.5  -84.5   730    -5 A     America/…\n 8 0G7   Finger Lakes Regional Airport   42.9  -76.8   492    -5 A     America/…\n 9 0P2   Shoestring Aviation Airfield    39.8  -76.6  1000    -5 U     America/…\n10 0S9   Jefferson County Intl           48.1 -123.    108    -8 A     America/…\n# ℹ 1,448 more rows\n```\n:::\n:::\n\n\n* A tabela `planes` registra dados sobre cada aeronave. Podemos identificar uma aeronave pelo seu número de cauda (`tailnum`), tornando o número de cauda a chave primária.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplanes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,322 × 9\n   tailnum  year type              manufacturer model engines seats speed engine\n   <chr>   <int> <chr>             <chr>        <chr>   <int> <int> <int> <chr> \n 1 N10156   2004 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 2 N102UW   1998 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 3 N103US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 4 N104UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 5 N10575   2002 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 6 N105UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 7 N107US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 8 N108UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 9 N109UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n10 N110UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n# ℹ 3,312 more rows\n```\n:::\n:::\n\n\n* A tabela `weather` registra dados sobre o clima nos aeroportos de origem. Você pode identificar cada observação pela **combinação** de localização e horário, tornando a origem (`origin`) e o horário (`time_hour`) a **chave primária composta**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 26,115 × 15\n   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed\n   <chr>  <int> <int> <int> <int> <dbl> <dbl> <dbl>    <dbl>      <dbl>\n 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 \n 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06\n 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 \n 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 \n 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 \n 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 \n 7 EWR     2013     1     1     7  39.0  28.0  64.4      240      15.0 \n 8 EWR     2013     1     1     8  39.9  28.0  62.2      250      10.4 \n 9 EWR     2013     1     1     9  39.9  28.0  62.2      260      15.0 \n10 EWR     2013     1     1    10  41    28.0  59.6      260      13.8 \n# ℹ 26,105 more rows\n# ℹ 5 more variables: wind_gust <dbl>, precip <dbl>, pressure <dbl>,\n#   visib <dbl>, time_hour <dttm>\n```\n:::\n:::\n\n\n**Uma chave estrangeira é uma variável (ou conjunto de variáveis) que corresponde a uma chave primária em outra tabela**. Por exemplo:\n\n* `flights$tailnum` é uma chave estrangeira que corresponde à chave primária `planes$tailnum`.\n* `flights$carrier` é uma chave estrangeira que corresponde à chave primária `airlines$carrier`.\n\nPodemos ver como cada banco de dados está relacionado com os demais na Figura abaixo.\n![Descrição da Imagem](./imagens/ncyflights13.png)\n\n* A Tabela “flights” está vinculada à tabela “planes” por meio de uma variável única, “tailnum”.\n\n* A Tabela “flights” está vinculada à tabela “airlines” por meio de uma variável única, “carrier”.\n\n* A Tabela “flights” está vinculada à tabela “airports” de duas maneiras: por meio das variáveis “origin” e “dest”.\n\n* A Tabela “flights” está vinculada à tabela “weather” por meio das variáveis “origin” (localização), “year”, “month”, “day” e “hour”.\n\nNote que as chaves primárias e estrangeiras têm quase sempre os mesmos nomes, o que, como veremos em breve, tornará sua vida de junção muito mais fácil. Também vale a pena observar a relação oposta: quase todos os nomes de variáveis usados em várias tabelas têm o mesmo significado em cada lugar. Há apenas uma exceção: o ano (`year`) significa o ano de partida nos voos (`flights`) e o ano de fabricação nas aeronaves (`planes`).\n\n#### 4.6.2.2 Verificação de Chaves Primárias\nAgora que identificamos as chaves primárias em cada tabela, é uma boa prática verificar se elas realmente identificam de forma única cada observação. Uma maneira de fazer isso é contar as chaves primárias e procurar entradas em que `n()` seja maior que um.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplanes %>% \n  count(tailnum) %>%\n  filter(n > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 2\n# ℹ 2 variables: tailnum <chr>, n <int>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nweather %>%\n  count(time_hour, origin) %>%\n  filter(n > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 3\n# ℹ 3 variables: time_hour <dttm>, origin <chr>, n <int>\n```\n:::\n:::\n\n\nAlém de termos chave primária única, é importante que não haja valores faltantes, se um valor estiver ausente, ele não poderá identificar uma observação.\n\n::: {.cell}\n\n```{.r .cell-code}\nplanes %>%\n  filter(is.na(tailnum))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 9\n# ℹ 9 variables: tailnum <chr>, year <int>, type <chr>, manufacturer <chr>,\n#   model <chr>, engines <int>, seats <int>, speed <int>, engine <chr>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nweather %>% \n  filter(is.na(time_hour) | is.na(origin))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 15\n# ℹ 15 variables: origin <chr>, year <int>, month <int>, day <int>, hour <int>,\n#   temp <dbl>, dewp <dbl>, humid <dbl>, wind_dir <dbl>, wind_speed <dbl>,\n#   wind_gust <dbl>, precip <dbl>, pressure <dbl>, visib <dbl>,\n#   time_hour <dttm>\n```\n:::\n:::\n\n\n### 4.6.3 Combinando dados\n\nBom, agora que compreendemos a importância de chaves vamos agora introdur dois tipos importantes de junções:\n\n* Junções mutacionais, que adicionam novas variáveis a um conjunto de dados a partir de observações correspondentes em outro banco de dados. São elas:\n  * `inner_join`;\n  * `full_join`;\n  * `left_join`;\n  * `right_join`.\n* Junções de filtragem, que filtram observações de um quadro de dados com base em se elas correspondem ou não a uma observação em outro banco de dados.\n  * `semi_join()`;\n  * `anti_join()`.\n  \n### 4.6.4 Junções Mutacionais\n\nUma junção mutacional (*mutating join*) permite combinar **variáveis de dois conjuntos de dados**: primeiro, ele corresponde às observações através de suas chaves e, em seguida, copia as variáveis de um conjunto de dados para o outro. Assim como a função `mutate()`, as funções de `join` adicionam variáveis *à direita*, portanto, se o seu conjunto de dados tiver muitas variáveis, as novas variáveis não serão imediatamente visíveis. Para facilitar a compreensão dos exemplos a seguir, criaremos um conjunto de dados mais suscinto com apenas seis variáveis, e apenas com vôos com distância superior à 1000km:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 <- flights %>% \n  filter(distance > 2000) %>% \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 51,695 × 6\n    year time_hour           origin dest  tailnum carrier\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>  \n 1  2013 2013-01-01 06:00:00 JFK    LAX   N29129  UA     \n 2  2013 2013-01-01 06:00:00 EWR    SFO   N53441  UA     \n 3  2013 2013-01-01 06:00:00 EWR    LAS   N76515  UA     \n 4  2013 2013-01-01 06:00:00 JFK    SFO   N532UA  UA     \n 5  2013 2013-01-01 06:00:00 EWR    PHX   N807AW  US     \n 6  2013 2013-01-01 06:00:00 JFK    PHX   N535UW  US     \n 7  2013 2013-01-01 06:00:00 EWR    LAX   N33289  UA     \n 8  2013 2013-01-01 06:00:00 EWR    SNA   N38727  UA     \n 9  2013 2013-01-01 06:00:00 JFK    LAS   N558JB  B6     \n10  2013 2013-01-01 07:00:00 JFK    SFO   N705TW  DL     \n# ℹ 51,685 more rows\n```\n:::\n:::\n\n\n#### 4.6.4.1 Left Join\nO `left join` retorna todas as linhas do primeiro conjunto de dados (tabela à esquerda) e as linhas correspondentes do segundo conjunto de dados (tabela à direita), se houver correspondência. Se não houver correspondência na tabela à direita, os valores serão preenchidos com `NA` (valores ausentes).\n\n![Descrição da Imagem](./imagens/leftjoin.svg)\nSuponha que gostariamos de adicionar o nome completo da companhia aerea no nosso banco de dados. Para isso, precisamos combinar as informações de `flights2` com `airlines`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2_airlines = \n  flights2  %>% \n  left_join(., airlines)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(carrier)`\n```\n:::\n:::\n\n\nNote que, por definição, a função buscou a chave primária como `carrier`. Nesse caso, como temos apenas uma chave, é viável fazermos isso. Contudo, é uma boa prática definirmos qual a chave que gostaríamos de combinar os bancos de dados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2_airlines = \n  flights2  %>% \n  left_join(., airlines, \n            by = \"carrier\")\n\nflights2_airlines\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 51,695 × 7\n    year time_hour           origin dest  tailnum carrier name                 \n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>                \n 1  2013 2013-01-01 06:00:00 JFK    LAX   N29129  UA      United Air Lines Inc.\n 2  2013 2013-01-01 06:00:00 EWR    SFO   N53441  UA      United Air Lines Inc.\n 3  2013 2013-01-01 06:00:00 EWR    LAS   N76515  UA      United Air Lines Inc.\n 4  2013 2013-01-01 06:00:00 JFK    SFO   N532UA  UA      United Air Lines Inc.\n 5  2013 2013-01-01 06:00:00 EWR    PHX   N807AW  US      US Airways Inc.      \n 6  2013 2013-01-01 06:00:00 JFK    PHX   N535UW  US      US Airways Inc.      \n 7  2013 2013-01-01 06:00:00 EWR    LAX   N33289  UA      United Air Lines Inc.\n 8  2013 2013-01-01 06:00:00 EWR    SNA   N38727  UA      United Air Lines Inc.\n 9  2013 2013-01-01 06:00:00 JFK    LAS   N558JB  B6      JetBlue Airways      \n10  2013 2013-01-01 07:00:00 JFK    SFO   N705TW  DL      Delta Air Lines Inc. \n# ℹ 51,685 more rows\n```\n:::\n:::\n\n\n#### 4.6.4.2 Right Join\n\nO `right_join` retorna apenas as linhas do primeiro conjunto de dados (tabela à esquerda) se houver correspondência com o segundo conjunto de dados (tabela à direita). Se não houver correspondência na tabela à esquerda, os valores serão preenchidos com `NA` (valores ausentes).\n\n![Descrição da Imagem](./imagens/righttjoin.svg)\n\nSuponha que, temos interesse em buscar informações acerca dos dos vôos realizados pelos aviões em `flights2`. Para isso, basta unirmos as tabelas `planes` com `flights2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplanes_flights = flights2 %>% \n  right_join(planes, by = \"tailnum\")\n\nplanes_flights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50,720 × 14\n   year.x time_hour           origin dest  tailnum carrier year.y type          \n    <int> <dttm>              <chr>  <chr> <chr>   <chr>    <int> <chr>         \n 1   2013 2013-01-01 06:00:00 JFK    LAX   N29129  UA        1998 Fixed wing mu…\n 2   2013 2013-01-01 06:00:00 EWR    SFO   N53441  UA          NA Fixed wing mu…\n 3   2013 2013-01-01 06:00:00 EWR    LAS   N76515  UA        2008 Fixed wing mu…\n 4   2013 2013-01-01 06:00:00 EWR    PHX   N807AW  US        1999 Fixed wing mu…\n 5   2013 2013-01-01 06:00:00 JFK    PHX   N535UW  US        2009 Fixed wing mu…\n 6   2013 2013-01-01 06:00:00 EWR    LAX   N33289  UA        2004 Fixed wing mu…\n 7   2013 2013-01-01 06:00:00 EWR    SNA   N38727  UA        1999 Fixed wing mu…\n 8   2013 2013-01-01 06:00:00 JFK    LAS   N558JB  B6        2003 Fixed wing mu…\n 9   2013 2013-01-01 07:00:00 JFK    SFO   N705TW  DL        1997 Fixed wing mu…\n10   2013 2013-01-01 07:00:00 JFK    LAX   N627VA  VX        2006 Fixed wing mu…\n# ℹ 50,710 more rows\n# ℹ 6 more variables: manufacturer <chr>, model <chr>, engines <int>,\n#   seats <int>, speed <int>, engine <chr>\n```\n:::\n:::\n\n\n#### 4.6.4.3 Inner Join\nO `inner join` retorna apenas as linhas que têm correspondências em ambos os conjuntos de dados. Ou seja, ele preserva apenas as observações com chaves correspondentes em ambas as tabelas.\n\n![Descrição da Imagem](./imagens/innerjoin.svg)\n\n Suponha que, temos interesse em buscar informações acerca dos aeroportos de origem realizados pelos aviões em `flights2`. Porém, apenas temos interesse em informações que aparecem em ambos bancos. Para isso, basta unirmos as tabelas `flights2` com `airports`.\n \n\n::: {.cell}\n\n```{.r .cell-code}\norigin_flights = flights2 %>% \n  inner_join(airports, by = c(\"origin\"= \"faa\"))\n\norigin_flights = flights2 %>% \n  inner_join(airports, join_by(origin == faa))\n\norigin_flights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 51,695 × 13\n    year time_hour           origin dest  tailnum carrier name         lat   lon\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>      <dbl> <dbl>\n 1  2013 2013-01-01 06:00:00 JFK    LAX   N29129  UA      John F Ke…  40.6 -73.8\n 2  2013 2013-01-01 06:00:00 EWR    SFO   N53441  UA      Newark Li…  40.7 -74.2\n 3  2013 2013-01-01 06:00:00 EWR    LAS   N76515  UA      Newark Li…  40.7 -74.2\n 4  2013 2013-01-01 06:00:00 JFK    SFO   N532UA  UA      John F Ke…  40.6 -73.8\n 5  2013 2013-01-01 06:00:00 EWR    PHX   N807AW  US      Newark Li…  40.7 -74.2\n 6  2013 2013-01-01 06:00:00 JFK    PHX   N535UW  US      John F Ke…  40.6 -73.8\n 7  2013 2013-01-01 06:00:00 EWR    LAX   N33289  UA      Newark Li…  40.7 -74.2\n 8  2013 2013-01-01 06:00:00 EWR    SNA   N38727  UA      Newark Li…  40.7 -74.2\n 9  2013 2013-01-01 06:00:00 JFK    LAS   N558JB  B6      John F Ke…  40.6 -73.8\n10  2013 2013-01-01 07:00:00 JFK    SFO   N705TW  DL      John F Ke…  40.6 -73.8\n# ℹ 51,685 more rows\n# ℹ 4 more variables: alt <dbl>, tz <dbl>, dst <chr>, tzone <chr>\n```\n:::\n:::\n\n\n#### 4.6.4.4 Full Join\nO `full_join` retorna todas as linhas de ambos os conjuntos de dados (tabelas à esquerda e à direita). Ele preenche com `NA` aqueles valores que não têm correspondência em uma das tabelas.\n\n![Descrição da Imagem](./imagens/fulljoin.svg)\n\nSuponha que, temos interesse em buscar informações acerca dos aeroportos de destino realizados pelos aviões em `flights2`. Porém, apenas temos interesse em todas informações que aparecem em ambos bancos. Para isso, basta unirmos as tabelas `flights2` com `airports`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndest_flights = flights2 %>% \n  full_join(airports, by = c(\"dest\"= \"faa\"))\n\ndest_flights = flights2 %>% \n  full_join(airports, join_by(dest == faa))\n\ndest_flights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,137 × 13\n    year time_hour           origin dest  tailnum carrier name         lat   lon\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>      <dbl> <dbl>\n 1  2013 2013-01-01 06:00:00 JFK    LAX   N29129  UA      Los Angel…  33.9 -118.\n 2  2013 2013-01-01 06:00:00 EWR    SFO   N53441  UA      San Franc…  37.6 -122.\n 3  2013 2013-01-01 06:00:00 EWR    LAS   N76515  UA      Mc Carran…  36.1 -115.\n 4  2013 2013-01-01 06:00:00 JFK    SFO   N532UA  UA      San Franc…  37.6 -122.\n 5  2013 2013-01-01 06:00:00 EWR    PHX   N807AW  US      Phoenix S…  33.4 -112.\n 6  2013 2013-01-01 06:00:00 JFK    PHX   N535UW  US      Phoenix S…  33.4 -112.\n 7  2013 2013-01-01 06:00:00 EWR    LAX   N33289  UA      Los Angel…  33.9 -118.\n 8  2013 2013-01-01 06:00:00 EWR    SNA   N38727  UA      John Wayn…  33.7 -118.\n 9  2013 2013-01-01 06:00:00 JFK    LAS   N558JB  B6      Mc Carran…  36.1 -115.\n10  2013 2013-01-01 07:00:00 JFK    SFO   N705TW  DL      San Franc…  37.6 -122.\n# ℹ 53,127 more rows\n# ℹ 4 more variables: alt <dbl>, tz <dbl>, dst <chr>, tzone <chr>\n```\n:::\n:::\n\n\n### 4.6.5 Junções de Filtragem\nComo o próprio nome sugere, a ação principal de uma junção de filtragem é filtrar as linhas. Existem dois tipos: semi-junções e anti-junções. Semi-junções mantêm todas as linhas em `x` que têm uma correspondência em `y`. Por exemplo, poderíamos usar uma semi-junção para filtrar o conjunto de dados de aeroportos (`airports`) para mostrar apenas os aeroportos de origem:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairports %>% \n  semi_join(flights2, join_by(faa == origin))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 8\n  faa   name                  lat   lon   alt    tz dst   tzone           \n  <chr> <chr>               <dbl> <dbl> <dbl> <dbl> <chr> <chr>           \n1 EWR   Newark Liberty Intl  40.7 -74.2    18    -5 A     America/New_York\n2 JFK   John F Kennedy Intl  40.6 -73.8    13    -5 A     America/New_York\n```\n:::\n:::\n\n\nAnti-junções são o oposto: elas retornam todas as linhas em `x` que não têm correspondência em `y`. São úteis para encontrar valores ausentes que são implícitos nos dados. Valores implicitamente ausentes não aparecem como NAs, mas sim existem apenas como uma ausência. Por exemplo, podemos encontrar linhas ausentes em aeroportos procurando voos que não tenham um aeroporto de destino correspondente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>%\n  anti_join(airports, join_by(dest == faa)) %>% \n  distinct(dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 1\n  dest \n  <chr>\n1 BQN  \n2 SJU  \n3 STT  \n4 PSE  \n```\n:::\n:::\n\n\n## 4.7 Exercícios\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(nycflights13)\nflights_voos <- flights\nflights_cias <- airlines\nflights_aeroportos <- airports\nflights_aviao <- planes\nflights_clima <- weather\n```\n:::\n\n\n1. Para vôos com atraso superior a 24 horas em `flights`, verifique as condições climáticas em `weather`. Há algum padrão? Quais os meses do ano em que você encontra os maiores atrasos?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filtrar os voos com atraso superior a 24 horas em \"flights\"\nvoos_atraso_24h <- flights %>%\n  filter(arr_delay > 12)\n\n# Juntar os dados de clima de \"weather\" com os voos atrasados\nvoos_clima_atraso <- voos_atraso_24h %>%\n  left_join(weather, by = c(\"year\", \"month\", \"day\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in left_join(., weather, by = c(\"year\", \"month\", \"day\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 1 of `x` matches multiple rows in `y`.\nℹ Row 1 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n```\n:::\n\n```{.r .cell-code}\n# Agregar e calcular a contagem de voos atrasados por mês\ncontagem_atrasos_por_mes <- voos_clima_atraso %>%\n  group_by(month) %>%\n  summarise(total_atrasos = n())\n\n# Exibir os meses com os maiores atrasos\nmeses_maior_atraso <- contagem_atrasos_por_mes %>%\n  arrange(desc(total_atrasos)) %>%\n  head()\n\n# Exibir a tabela de frequência dos meses com os maiores atrasos\nprint(meses_maior_atraso)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  month total_atrasos\n  <int>         <int>\n1     7        684804\n2    12        676632\n3     6        642168\n4     4        605641\n5     8        538609\n6     3        506040\n```\n:::\n:::\n\n\n2. Encontre os 20 destinos mais comuns e identifique seu aeroporto. Qual a temperatura média (mensal) em Celcius desses lugares? E a precipitação média, em cm?\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convertendo temperatura de °F para °C e polegadas para cm\nflights_clima <- flights_clima %>%\n  mutate(temp_celsius = (temp - 32) / 1.8,\n         precip_cm = precip * 2.54)\n\n# Flitrando flight voos e identificando seu aeroporto\nflights_destinos <- flights_voos %>%\n  inner_join(airports, by = c(\"dest\"= \"faa\")) %>%\n  select(dest, origin, name, time_hour)\n\n# Encontrando os 20 maiores destino, e media de temperatura e precipitação\nq2 <- flights_destinos %>%\n  left_join(., flights_clima) %>%\n  select(dest, origin, name, time_hour, temp_celsius, precip_cm) %>%\n  group_by(dest, name) %>%\n  summarise(media_temp = mean(temp_celsius, na.rm = T),\n            media_precip = mean(precip_cm, na.rm = T)) %>%\n  head(20)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(origin, time_hour)`\n`summarise()` has grouped output by 'dest'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\n# Exibindo o resultado\nprint(q2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 4\n# Groups:   dest [20]\n   dest  name                               media_temp media_precip\n   <chr> <chr>                                   <dbl>        <dbl>\n 1 ABQ   Albuquerque International Sunport        16.0      0.0136 \n 2 ACK   Nantucket Mem                            23.5      0.0116 \n 3 ALB   Albany Intl                              10.1      0.00629\n 4 ANC   Ted Stevens Anchorage Intl               28.7      0      \n 5 ATL   Hartsfield Jackson Atlanta Intl          14.0      0.0123 \n 6 AUS   Austin Bergstrom Intl                    13.9      0.0138 \n 7 AVL   Asheville Regional Airport               18.9      0.0154 \n 8 BDL   Bradley Intl                             12.8      0.0125 \n 9 BGR   Bangor Intl                              16.4      0.00563\n10 BHM   Birmingham Intl                          15.3      0.0208 \n11 BNA   Nashville Intl                           14.8      0.0119 \n12 BOS   General Edward Lawrence Logan Intl       14.0      0.0124 \n13 BTV   Burlington Intl                          14.0      0.0123 \n14 BUF   Buffalo Niagara Intl                     13.2      0.00970\n15 BUR   Bob Hope                                 13.4      0.00688\n16 BWI   Baltimore Washington Intl                11.2      0.00990\n17 BZN   Gallatin Field                           14.3      0      \n18 CAE   Columbia Metropolitan                    13.8      0.0100 \n19 CAK   Akron Canton Regional Airport            15.2      0.0132 \n20 CHO   Charlottesville-Albemarle                11.2      0.00684\n```\n:::\n:::\n\n\n\n3. Inclua uma coluna com a cia aérea na tabela `planes`. Quantas companhias áreas voaram cada avião naquele ano?\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filtrando voos de cada companhia aerea\nflights_by_cia <- flights_cias %>%\n  inner_join(flights_voos, by = \"carrier\") %>%\n  group_by(tailnum, carrier, name) %>%\n  summarise(total_voos = n())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'tailnum', 'carrier'. You can override\nusing the `.groups` argument.\n```\n:::\n\n```{.r .cell-code}\n# Verificando se a filtragem está correta\nprint(sum(flights_by_cia$total_voos))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 336776\n```\n:::\n\n```{.r .cell-code}\nprint(nrow(flights_voos))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 336776\n```\n:::\n\n```{.r .cell-code}\n# Juntando as informações das companhias aéreas com os aviões\nplanes_with_airlines <- flights_aviao %>%\n  left_join(flights_by_cia, \n            by = \"tailnum\")\n\n# Exibindo o resultado\nprint(planes_with_airlines)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,339 × 12\n   tailnum  year type      manufacturer model engines seats speed engine carrier\n   <chr>   <int> <chr>     <chr>        <chr>   <int> <int> <int> <chr>  <chr>  \n 1 N10156   2004 Fixed wi… EMBRAER      EMB-…       2    55    NA Turbo… EV     \n 2 N102UW   1998 Fixed wi… AIRBUS INDU… A320…       2   182    NA Turbo… US     \n 3 N103US   1999 Fixed wi… AIRBUS INDU… A320…       2   182    NA Turbo… US     \n 4 N104UW   1999 Fixed wi… AIRBUS INDU… A320…       2   182    NA Turbo… US     \n 5 N10575   2002 Fixed wi… EMBRAER      EMB-…       2    55    NA Turbo… EV     \n 6 N105UW   1999 Fixed wi… AIRBUS INDU… A320…       2   182    NA Turbo… US     \n 7 N107US   1999 Fixed wi… AIRBUS INDU… A320…       2   182    NA Turbo… US     \n 8 N108UW   1999 Fixed wi… AIRBUS INDU… A320…       2   182    NA Turbo… US     \n 9 N109UW   1999 Fixed wi… AIRBUS INDU… A320…       2   182    NA Turbo… US     \n10 N110UW   1999 Fixed wi… AIRBUS INDU… A320…       2   182    NA Turbo… US     \n# ℹ 3,329 more rows\n# ℹ 2 more variables: name <chr>, total_voos <int>\n```\n:::\n:::\n\n\n\n\nInclua a latitude e longitude de cada origem destino na tabela `flights`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# filtrando flights_aeroportos\nflights_lat_long <- select(flights_aeroportos, faa, lat, lon)\n\n# Agora, vamos juntar as informações de latitude e longitude com a tabela \"flights\"\nflights_coordinates <- flights_voos %>%\n  select(origin, dest) %>%\n  left_join(flights_lat_long, by = c(\"origin\" = \"faa\")) %>%\n  rename(origin_lat = lat, origin_lon = lon) %>%\n  left_join(flights_lat_long, by = c(\"dest\" = \"faa\")) %>%\n  rename(dest_lat = lat, dest_lon = lon)\n\n# Exibir o resultado\nprint(flights_coordinates)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 × 6\n   origin dest  origin_lat origin_lon dest_lat dest_lon\n   <chr>  <chr>      <dbl>      <dbl>    <dbl>    <dbl>\n 1 EWR    IAH         40.7      -74.2     30.0    -95.3\n 2 LGA    IAH         40.8      -73.9     30.0    -95.3\n 3 JFK    MIA         40.6      -73.8     25.8    -80.3\n 4 JFK    BQN         40.6      -73.8     NA       NA  \n 5 LGA    ATL         40.8      -73.9     33.6    -84.4\n 6 EWR    ORD         40.7      -74.2     42.0    -87.9\n 7 EWR    FLL         40.7      -74.2     26.1    -80.2\n 8 LGA    IAD         40.8      -73.9     38.9    -77.5\n 9 JFK    MCO         40.6      -73.8     28.4    -81.3\n10 LGA    ORD         40.8      -73.9     42.0    -87.9\n# ℹ 336,766 more rows\n```\n:::\n:::\n\n\n\n\n## 4.8 Organização de dados\nCompreender a organização de dados é fundamental para análises estatísticas eficazes. Quando trabalhamos com dados em R, é importante seguir as regras que tornam um conjunto de dados *tidy* (organizado), o que facilita o processamento e a interpretação dos dados. Existem três regras inter-relacionadas que tornam um conjunto de dados *tidy*:\n\n1. **Cada variável é uma coluna; cada coluna é uma variável**: Isso significa que cada característica ou medida que você está analisando deve ser representada por uma coluna separada no conjunto de dados.\n\n  * Por exemplo, se você estiver trabalhando com dados de pacientes, as variáveis como idade, gênero, altura e peso devem ser colunas separadas.\n  \n2. **Cada observação é uma linha; cada linha é uma observação**: Cada linha do conjunto de dados deve representar uma única observação, caso ou instância. Isso garante que os dados estejam organizados de maneira que seja fácil identificar e comparar diferentes casos.\n\n  * Por exemplo, cada linha pode representar um paciente individual em um conjunto de dados médicos.\n\n3. **Cada valor é uma célula; cada célula é um único valor**: Cada célula no conjunto de dados deve conter um único valor. Isso significa que não deve haver combinações de valores em uma única célula. Cada célula deve conter uma informação única e específica relacionada à variável e à observação correspondente.\n\nAo seguir essas três regras, você cria um conjunto de dados tidy que é fácil de manipular, visualizar e analisar. Essa organização facilita a utilização de funções como `pivot_longer` e `pivot_wider` para remodelar os dados quando necessário a fim de adaptá-los às necessidades de sua análise estatística em R\n\n![Descrição da Imagem](./imagens/tidy_data.svg)\n\n### 4.8.1 Pivotagem\n\nPivotar, como o próprio nome sugere, é um processo de transformação de um conjunto de dados, no qual as colunas e linhas são reorganizadas de tal forma que os valores que originalmente estavam dispostos em linhas agora são apresentados como colunas, e vice-versa. Esse procedimento é fundamental para preparar e organizar dados para análises estatísticas e visualizações mais eficazes.\n\n#### 4.8.1.1 Formato Wide (Largo) e Formato Long (Longo)\n\nEm ciência de dados, é comum falarmos em dois formatos principais: o formato *wide* (largo) e o formato *long* (longo). Essas representações são especialmente úteis para diferentes tipos de análises e visualizações.\n\n1. **Formato Wide (Largo)**: Nesse formato, os dados são organizados de forma que cada variável é representada por uma coluna separada e cada observação (ou instância) ocupa uma única linha. Isso significa que as informações são distribuídas em várias colunas, tornando-o mais adequado para conjuntos de dados com poucas variáveis, onde as informações são bem condensadas.\n\n![Descrição da Imagem](./imagens/tidy_data.svg)\n\n2. **Formato Long (Longo)**: Já no formato long (ou longo), os dados são organizados de maneira que as variáveis estão empilhadas em uma única coluna, enquanto uma coluna adicional é usada para indicar o nome da variável. Cada observação é representada por uma linha separada. Esse formato é ideal quando se trabalha com conjuntos de dados mais complexos, nos quais as informações estão espalhadas em várias categorias ou momentos de tempo, por exemplo.\n\n![Descrição da Imagem](./imagens/long_data.svg)\n\n### 4.8.2 Exercício\nCom os dois conjuntos de dados abaixo, defina qual a versão *organizada* dos dados.\n\n1. **Conjunto 1:**\n\n* **Wide**:\n\n|Nome     |Idade|Peso (kg)|Gênero   |\n|---------|-----|---------|---------|\n|Alice    |34   |52.16    |Feminino |\n|Bob      |35   |72.57    |Masculino|\n|Christine|38   |56.70    |Feminino |\n\n* **Long**:\n\n|Nome     |Variável |Valor     |\n|---------|---------|----------|\n|Alice    |Idade    |34        |\n|Alice    |Peso (kg)|52.16     |\n|Alice    |Gênero   |Feminino  |\n|Bob      |Idade    |35        |\n|Bob      |Peso (kg)|72.57     |\n|Bob      |Gênero   |Masculino |\n|Christine|Idade    |38        |\n|Christine|Peso (kg)|56.70     |\n|Christine|Gênero   |Feminino  |\n\n1. **Conjunto 2:**\n\n* **Wide**:\n\n|Tamanho da Pedra |Tratamento A - Recuperados|Tratamento A - Falhas|Tratamento B - Recuperados|Tratamento B - Falhas|\n|-----------------|--------------------------|---------------------|--------------------------|---------------------|\n|Pequeno          |81                        |6                    |234                       |36                   |\n|Grande           |192                       |71                   |55                        |25                   |\n\n* **Long**:\n\n|Tamanho da Pedra   |Tratamento   |Recuperado |Falha  |\n|-------------------|-------------|-----------|-------|\n|Pequena            |A            |81         |6      |\n|Pequena            |B            |234        |36     |\n|Grande             |A            |192        |71     |\n|Grande             |B            |55         |25     |\n\n### 4.8.2 Pivotando dados em R\n\nPara aprendermos sobre os tipos de *pivot* em R, vamos utilizar o banco de dados `table1`. Esse banco de dados possui dados de casos reportados de Tuberculose e o tamanho da população em dois anos para três países. Esses dados são provenientes dos dados `who`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(tidyr)\nrequire(magrittr)\nrequire(dplyr)\n\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n:::\n:::\n\n\n#### 4.8.2.1 `pivot_wider`\n\nA função `pivot_wider` é usada para transformar um conjunto de dados de um formato longo para um formato largo. Isso é útil quando temos informações em uma única coluna que desejamos espalhar em várias colunas.\n\n* **Sintaxe:**\n\n`pivot_wider(data, names_from, values_from)` - `data`: O conjunto de dados que você deseja transformar. - `names_from`: A coluna que contém os nomes das variáveis que você deseja espalhar. - `values_from`: A coluna que contém os valores correspondentes a essas variáveis.\n\n**Exemplo**: Transformando em dados de `table1` em wide.\n\n* Suponha que queremos o número de casos por ano.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable1 %>% \n  select(country, year, cases) %>% \n  pivot_wider(names_from = year, values_from = cases)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n:::\n:::\n\n\n#### 4.8.2.2 `pivot_longer` \nA função pivot_longer é utilizada para transformar um conjunto de dados de um formato largo (wide) para um formato longo (long). Isso é útil quando temos variáveis espalhadas em várias colunas e desejamos organizar esses dados em uma única coluna, tornando-os mais adequados para análises e visualizações. Geralmente, usamos `pivot_longer` quando temos variáveis empilhadas em diferentes colunas e queremos reunir essas informações em uma única coluna.\n\n* **Sintaxe:** `pivot_longer(data, cols, names_to, values_to)`\n  * `data`: O conjunto de dados que você deseja transformar.\n  * `cols`: As colunas que você deseja empilhar no formato longo.\n  * `names_to`: O nome da nova coluna que irá conter os nomes das variáveis empilhadas.\n  * `values_to`: O nome da nova coluna que irá conter os valores das variáveis empilhadas.\n\n**Exemplo**: Transformando em dados de `table1` em long.\n\n* Suponha que queremos os casos e o tamanho da população como uma variável.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable1 %>% \n  pivot_longer(cols = -c(country, year), \n               names_to = \"variavel\", \n               values_to = \"tamanho\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 4\n   country      year variavel      tamanho\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n:::\n:::\n\n\n#### 4.8.2.3 Separando observações\n\nA função separate() divide uma única coluna em várias colunas, dividindo-a sempre que um caractere separador aparece. Vamos considerar o exemplo da `table3`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n:::\n\n\nNote que a coluna `rate` é na verdade uma coluna onde temos os casos e a população separadas por “/”. Podemos separar essa coluna em duas utilizando a função separate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseparated = table3 %>% \n  separate(rate, into = c(\"cases\", \"population\"))\n```\n:::\n\n\nCaso tenhamos interesse em uni-las novamente, podemos utilizar a função `unite`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseparated %>% \n  unite(rate, cases, population, sep = \"/\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n:::\n\n\n### 4.8.3 Exemplo\n\nVamos utilizar os dados de notificações de casos provenientes do site do [WHO](https://www.who.int/teams/global-tuberculosis-programme/data).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTB <- fread(\"./datasets/TB.csv.gz\")\n```\n:::\n\n\n\n\nEste conjunto de dados exemplifica uma situação comum na vida real, onde os dados estão desorganizados e não estão em um formato adequado para análises. Ele apresenta colunas redundantes, códigos de variáveis incomuns e uma abundância de valores ausentes. Em suma, está em uma condição “bagunçada” e precisaremos de várias etapas para limpá-lo e organizá-lo de forma apropriada. Assim como o pacote `dplyr`, o `tidyr` foi projetado para que cada função tenha uma função específica e bem definida. Isso significa que, em cenários da vida real, você geralmente precisará encadear várias dessas funções em uma sequência lógica para obter os dados em um estado utilizável.\n\nO ponto de partida mais eficaz geralmente é reunir as colunas que não são consideradas variáveis. Vamos examinar o que temos:\n\n1. **Country (país), iso2 e iso3**: Essas três colunas parecem redundantes e especificam o país de formas diferentes. Variável redundante.\n\n2. **Year (ano)**: É claramente uma variável que representa o ano em que os dados foram registrados.\n\n3. **Outras Colunas Não Identificadas**: As colunas restantes, como “new_sp_m014”, “new_ep_m014” e “new_ep_f014”, não sabemos o que representam ainda. De acordo com a estrutura dos nomes das colunas, elas provavelmente contêm valores, não são variáveis.\n\nPortanto, nossa primeira tarefa é agrupar todas as colunas, desde “new_sp_m014” até “newrel_f65”, porque ainda não compreendemos completamente o que essas colunas representam. Chamaremos essa variável genérica de “chave”. Além disso, sabemos que as células dessas colunas representam a contagem de casos, então criaremos uma variável chamada “casos” para armazenar esses valores.\n\nÉ importante observar que há muitos valores ausentes nos dados atuais. Para facilitar a análise inicial, usaremos a função “values_drop_na” para nos concentrarmos apenas nos valores que estão presentes, deixando os valores ausentes de lado temporariamente.\n\nDessa forma, estaremos prontos para começar o processo de organização e limpeza desses dados desorganizados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTB1 <- TB %>% \n  pivot_longer(\n    cols = -c(1:4), \n    names_to = \"chave\", \n    values_to = \"casos\", \n    values_drop_na = TRUE\n  )\nTB1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 97,867 × 6\n   country     iso2  iso3   year chave        casos\n   <chr>       <chr> <chr> <int> <chr>        <int>\n 1 Afghanistan AF    AFG    1997 new_sp_m014      0\n 2 Afghanistan AF    AFG    1997 new_sp_m1524    10\n 3 Afghanistan AF    AFG    1997 new_sp_m2534     6\n 4 Afghanistan AF    AFG    1997 new_sp_m3544     3\n 5 Afghanistan AF    AFG    1997 new_sp_m4554     5\n 6 Afghanistan AF    AFG    1997 new_sp_m5564     2\n 7 Afghanistan AF    AFG    1997 new_sp_m65       0\n 8 Afghanistan AF    AFG    1997 new_sp_f014      5\n 9 Afghanistan AF    AFG    1997 new_sp_f1524    38\n10 Afghanistan AF    AFG    1997 new_sp_f2534    36\n# ℹ 97,857 more rows\n```\n:::\n:::\n\n\nPara tentarmos entender a estrutura de chave, vamos contar ela.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTB1 %>% \n  count(chave)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 56 × 2\n   chave            n\n   <chr>        <int>\n 1 new_ep_f014   1029\n 2 new_ep_f1524  1018\n 3 new_ep_f2534  1018\n 4 new_ep_f3544  1018\n 5 new_ep_f4554  1014\n 6 new_ep_f5564  1014\n 7 new_ep_f65    1011\n 8 new_ep_m014   1035\n 9 new_ep_m1524  1023\n10 new_ep_m2534  1017\n# ℹ 46 more rows\n```\n:::\n:::\n\n\nSe olharmos o dicionário de variáveis, presente junto aos dados, estamos interessados nos casos, ou seja, nas variáveis descritas por `new`. Vamos então, filtrar nossos dados para manter apenas essas variáveis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTB1 %<>% filter(chave %like% \"^new\")\n```\n:::\n\n\nAlém disso, o dicionário das variáveis nos informa o seguinte:\n\n* As três primeiras letras de cada coluna indicam se a coluna contém casos novos (new) ou antigos (old) de tuberculose.\n\n* As letras seguintes descrevem o tipo de tuberculose:\n\n  * “rel” indica casos de recaída.\n\n  * “ep” indica casos de tuberculose extrapulmonar.\n\n  * “sn” indica casos de tuberculose pulmonar que não puderam ser diagnosticados por esfregaço pulmonar (*smear negative*).\n\n  * “sp” indica casos de tuberculose pulmonar que puderam ser diagnosticados por esfregaço pulmonar (*smear positive*).\n\n* A sexta letra indica o sexo dos pacientes com tuberculose, sendo “m” para masculino e “f” para feminino.\n\n* Os números restantes representam os grupos etários. O conjunto de dados agrupa os casos em sete faixas etárias:\n\n  * “014” = 0 a 14 anos\n\n  * “1524” = 15 a 24 anos\n\n  * “2534” = 25 a 34 anos\n\n  * “3544” = 35 a 44 anos\n\n  * “4554” = 45 a 54 anos\n\n  * “5564” = 55 a 64 anos\n\n  * “65” = 65 anos ou mais\n\nPara tornar o formato dos nomes das colunas mais consistente, é necessário fazer um pequeno ajuste: infelizmente, os nomes estão ligeiramente inconsistentes, pois em vez de “new_rel”, temos “newrel”. Para isso, vamos utilizar a função `str_replace()`, a ideia básica é simples: substituir os caracteres “newrel” por “new_rel”. Isso tornará todos os nomes das variáveis consistentes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTB2 <- TB1 %>% \n  mutate(chave = stringr::str_replace(chave, \"newrel\", \"new_rel\"))\nTB2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 97,867 × 6\n   country     iso2  iso3   year chave        casos\n   <chr>       <chr> <chr> <int> <chr>        <int>\n 1 Afghanistan AF    AFG    1997 new_sp_m014      0\n 2 Afghanistan AF    AFG    1997 new_sp_m1524    10\n 3 Afghanistan AF    AFG    1997 new_sp_m2534     6\n 4 Afghanistan AF    AFG    1997 new_sp_m3544     3\n 5 Afghanistan AF    AFG    1997 new_sp_m4554     5\n 6 Afghanistan AF    AFG    1997 new_sp_m5564     2\n 7 Afghanistan AF    AFG    1997 new_sp_m65       0\n 8 Afghanistan AF    AFG    1997 new_sp_f014      5\n 9 Afghanistan AF    AFG    1997 new_sp_f1524    38\n10 Afghanistan AF    AFG    1997 new_sp_f2534    36\n# ℹ 97,857 more rows\n```\n:::\n:::\n\n\nPodemos separar os valores em cada código usando duas etapas da função `separate()`. A primeira etapa dividirá os códigos em cada sublinhado (underscore).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTB3 <- TB2 %>% \n  separate(chave, c(\"new\", \"type\", \"sexage\"), \n           sep = \"_\")\nTB3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 97,867 × 8\n   country     iso2  iso3   year new   type  sexage casos\n   <chr>       <chr> <chr> <int> <chr> <chr> <chr>  <int>\n 1 Afghanistan AF    AFG    1997 new   sp    m014       0\n 2 Afghanistan AF    AFG    1997 new   sp    m1524     10\n 3 Afghanistan AF    AFG    1997 new   sp    m2534      6\n 4 Afghanistan AF    AFG    1997 new   sp    m3544      3\n 5 Afghanistan AF    AFG    1997 new   sp    m4554      5\n 6 Afghanistan AF    AFG    1997 new   sp    m5564      2\n 7 Afghanistan AF    AFG    1997 new   sp    m65        0\n 8 Afghanistan AF    AFG    1997 new   sp    f014       5\n 9 Afghanistan AF    AFG    1997 new   sp    f1524     38\n10 Afghanistan AF    AFG    1997 new   sp    f2534     36\n# ℹ 97,857 more rows\n```\n:::\n:::\n\n\n\nNesse caso, podemos eliminar a nova coluna, já que ela é constante em todo o conjunto de dados. Além disso, como mencionado anteriormente, as colunas “iso2” e “iso3” são redundantes e podem ser removidas. A eliminação de colunas não essenciais ajuda a simplificar o conjunto de dados e a economizar espaço de armazenamento.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTB4 <- TB3 %>% \n  select(-new, -iso2, -iso3)\n```\n:::\n\n\nAgora podemos separar o sexo e a idade.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTB5 <- TB4 %>% \n  separate(sexage, c(\"sexo\", \"idade\"), sep = 1)\nTB5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 97,867 × 6\n   country      year type  sexo  idade casos\n   <chr>       <int> <chr> <chr> <chr> <int>\n 1 Afghanistan  1997 sp    m     014       0\n 2 Afghanistan  1997 sp    m     1524     10\n 3 Afghanistan  1997 sp    m     2534      6\n 4 Afghanistan  1997 sp    m     3544      3\n 5 Afghanistan  1997 sp    m     4554      5\n 6 Afghanistan  1997 sp    m     5564      2\n 7 Afghanistan  1997 sp    m     65        0\n 8 Afghanistan  1997 sp    f     014       5\n 9 Afghanistan  1997 sp    f     1524     38\n10 Afghanistan  1997 sp    f     2534     36\n# ℹ 97,857 more rows\n```\n:::\n:::\n\n\n### 4.8.4 Exercícios\n1. Utilizando os dados de TB5, crie uma tabela em formato wide, com a quantidade de casos por país por ano. Cada ano deve ser chamado “Ano_.\n\n::: {.cell}\n\n```{.r .cell-code}\nTB6 <- TB5 %>%\n  pivot_wider(names_from = year, \n              values_from = casos,\n              names_prefix = \"Ano_\")\n\nTB6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11,338 × 46\n   country     type  sexo  idade Ano_1997 Ano_1998 Ano_1999 Ano_2000 Ano_2001\n   <chr>       <chr> <chr> <chr>    <int>    <int>    <int>    <int>    <int>\n 1 Afghanistan sp    m     014          0       30        8       52      129\n 2 Afghanistan sp    m     1524        10      129       55      228      379\n 3 Afghanistan sp    m     2534         6      128       55      183      349\n 4 Afghanistan sp    m     3544         3       90       47      149      274\n 5 Afghanistan sp    m     4554         5       89       34      129      204\n 6 Afghanistan sp    m     5564         2       64       21       94      139\n 7 Afghanistan sp    m     65           0       41        8       80      103\n 8 Afghanistan sp    f     014          5       45       25       93      146\n 9 Afghanistan sp    f     1524        38      350      139      414      799\n10 Afghanistan sp    f     2534        36      419      160      565      888\n# ℹ 11,328 more rows\n# ℹ 37 more variables: Ano_2002 <int>, Ano_2003 <int>, Ano_2004 <int>,\n#   Ano_2005 <int>, Ano_2006 <int>, Ano_2007 <int>, Ano_2008 <int>,\n#   Ano_2009 <int>, Ano_2010 <int>, Ano_2011 <int>, Ano_2012 <int>,\n#   Ano_2013 <int>, Ano_2014 <int>, Ano_2015 <int>, Ano_2016 <int>,\n#   Ano_2017 <int>, Ano_2018 <int>, Ano_2019 <int>, Ano_2020 <int>,\n#   Ano_2021 <int>, Ano_1995 <int>, Ano_1996 <int>, Ano_1980 <int>, …\n```\n:::\n:::\n\n\n2. Utilizando os dados de TB5, crie uma tabela em formato wide, com a quantidade de casos por país, ano, idade e sexo.\n  * Dica: Utilize o argumento `values_fn` da função.\n  \n3. Volte o banco criado em 1 e 2 para o formato `long`.\n\n\n## 4.9 Strings\n\nNo [Capítulo 2](https://gysi.quarto.pub/ce302/chapters/02_basicR.html) vimos como criar a fazer manipulações simples em *strings*. Agora vamos aprofundar nossos conhecimentos em manipulação de *strings*. Para trabalharmos com strings em R, podemos utilizar diversos pacotes, como o `base`, `stringr` e `stringi` . Nas aulas introdutórias focamos apenas nas funções do `base`, agora vamos focar nas funções do stringr. As funções do pacote `stringr` são, na sua maioria, wrappers das funções implementadas no `stringi` .\n\nStrings são objetos (ou variáveis) do tipo texto, e são delimitadas por aspas (duplas ou simples).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: tidyverse\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats 1.0.0     ✔ readr   2.1.4\n✔ ggplot2 3.4.3     ✔ stringr 1.5.0\n✔ purrr   1.0.1     ✔ tibble  3.2.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ data.table::between() masks dplyr::between()\n✖ tidyr::extract()      masks magrittr::extract()\n✖ dplyr::filter()       masks stats::filter()\n✖ data.table::first()   masks dplyr::first()\n✖ lubridate::hour()     masks data.table::hour()\n✖ lubridate::isoweek()  masks data.table::isoweek()\n✖ dplyr::lag()          masks stats::lag()\n✖ data.table::last()    masks dplyr::last()\n✖ lubridate::mday()     masks data.table::mday()\n✖ lubridate::minute()   masks data.table::minute()\n✖ lubridate::month()    masks data.table::month()\n✖ lubridate::quarter()  masks data.table::quarter()\n✖ lubridate::second()   masks data.table::second()\n✖ purrr::set_names()    masks magrittr::set_names()\n✖ purrr::transpose()    masks data.table::transpose()\n✖ lubridate::wday()     masks data.table::wday()\n✖ lubridate::week()     masks data.table::week()\n✖ lubridate::yday()     masks data.table::yday()\n✖ lubridate::year()     masks data.table::year()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(magrittr)\n\nx <- \"Seu nome aqui\"\ny <- 'Seu nome aqui'\n\nx == y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nCaso eu tenha interesse em criar uma string que contenha aspas, podemos cria-la da seguinte maneira:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_com_aspas <- \"Ela disse: 'Eu adoro lasanha.'\"\nvar_com_aspas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ela disse: 'Eu adoro lasanha.'\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(var_com_aspas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Ela disse: 'Eu adoro lasanha.'\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_com_aspas2 <- 'Ela disse: \"Eu adoro lasanha.\"'\nvar_com_aspas2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ela disse: \\\"Eu adoro lasanha.\\\"\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(var_com_aspas2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Ela disse: \"Eu adoro lasanha.\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_com_aspas3 <- \"Ela disse: \\\"Eu adoro lasanha.\\\"\"\nvar_com_aspas3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ela disse: \\\"Eu adoro lasanha.\\\"\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(var_com_aspas3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Ela disse: \"Eu adoro lasanha.\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_com_aspas4 <- 'Ela disse: \\'Eu adoro lasanha.\\''\nvar_com_aspas4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ela disse: 'Eu adoro lasanha.'\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(var_com_aspas4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Ela disse: 'Eu adoro lasanha.'\n```\n:::\n:::\n\n\n### 4.9.1 Caracteres especiais\n\nQuando estamos trabalhando com textos, frequentemente temos caracteres especiais. Caracteres especiais são caracteres que não são alfanuméricos e muitas vezes têm funções específicas ou significados especiais em linguagens de programação e processamento de texto. Aqui estão alguns exemplos comuns de caracteres especiais:\n\n* **Espaço em Branco**: O espaço em branco, muitas vezes representado como ” ” ou “\\s” em linguagens de programação, é um caractere especial que denota um espaço vazio entre palavras ou caracteres em uma string.\n  * Em R, podemos usar espaços em branco em strings de texto da maneira usual. Por exemplo:\n  \n\n::: {.cell}\n\n```{.r .cell-code}\ntexto <- \"Isso é um exemplo de texto com espaços em branco.\"\nstr_view(texto)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Isso é um exemplo de texto com espaços em branco.\n```\n:::\n:::\n\n  \n* **Nova Linha (\\n)**: O caractere “\\n” é usado para representar uma quebra de linha em uma string. Quando incluído em uma string, ele faz com que o texto subsequente seja exibido em uma nova linha.\n  * Para criar uma nova linha em uma string, podemos usar “\\n”. Isso é útil para criar múltiplas linhas de texto.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto_multilinhas <- \"Primeira linha\\nSegunda linha\\nTerceira linha\"\nstr_view(texto_multilinhas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Primeira linha\n    │ Segunda linha\n    │ Terceira linha\n```\n:::\n:::\n\n\n* **Tabulação (\\t)**: O caractere “\\t” representa uma tabulação horizontal. É frequentemente usado para criar recuos ou alinhar o texto em colunas.\n  * Para adicionar tabulações em uma string, você pode usar “\\t”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto_tabulado <- \"Primeira coluna\\tSegunda coluna\\tTerceira coluna\" \nstr_view(texto_tabulado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Primeira coluna{\\t}Segunda coluna{\\t}Terceira coluna\n```\n:::\n:::\n\n\n* **Caracteres de Escape (\\)**: O caractere “\\” é usado como um caractere de escape em muitas linguagens de programação. Isso significa que ele “escapa” o significado especial de outros caracteres, permitindo que você os inclua em uma string. Por exemplo, “\\” é usado para representar uma única barra invertida em vez de um caractere de escape.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto_com_barras <- \"Isso é uma única barra invertida: \\\\\"\nstr_view(texto_com_barras)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Isso é uma única barra invertida: \\\n```\n:::\n:::\n\n\n* **Caracteres Unicode**: Em linguagens de programação modernas, podemos usar caracteres Unicode em strings para representar uma ampla variedade de caracteres especiais de diferentes idiomas e símbolos.\n  * Podemos utilizar códigos Unicode para incluir caracteres especiais em uma string em R. Por exemplo, o símbolo do grau (°) pode ser representado pelo código Unicode “\\u00B0”.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto_unicode_grau <- \"A temperatura é de 25\\u00B0C.\"\nstr_view(texto_unicode_grau)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ A temperatura é de 25°C.\n```\n:::\n:::\n\n\n* O símbolo “\\n” (nova linha), pode ser representados usando seus códigos Unicode.\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto_multilinhas_unicode <- \"Primeira linha\\u000ASegunda linha\"\nstr_view(texto_multilinhas_unicode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Primeira linha\n    │ Segunda linha\n```\n:::\n:::\n\n\n* Caracteres matemáticos, como o símbolo de somatório ($\\sum$), podem ser representados com seus códigos Unicode.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimbolo_somatorio <- \"O símolo do somatório é: \\u2211\"\nstr_view(simbolo_somatorio)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ O símolo do somatório é: ∑\n```\n:::\n:::\n\n\n* Emojis também podem ser representados por Unicode.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemoji <- \"OMG! Também posso usar emoji! \\U1F631\"\nstr_view(emoji)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ OMG! Também posso usar emoji! 😱\n```\n:::\n:::\n\n\n### 4.9.2 Concatenando strings\nMuitas vezes temos interesse em combinar strings, como faziamos antes com a função `paste()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(nome = c(\"Ana\", \"Maria\", \"João\", NA), \n                 sobrenome= c(\"Santos\", \"Silva\", \"Souza\", NA))\ndf %>% \n  mutate(ola = str_c(\"Boa noite \", nome, \" \", sobrenome, \"!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   nome sobrenome                    ola\n1   Ana    Santos  Boa noite Ana Santos!\n2 Maria     Silva Boa noite Maria Silva!\n3  João     Souza  Boa noite João Souza!\n4  <NA>      <NA>                   <NA>\n```\n:::\n:::\n\n\nAlternativamente, quando temos diversas variáveis que queremos combinar, podemos utilizar a função `str_glue`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(mensagem = str_glue(\"Boa noite {nome} {sobrenome}!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   nome sobrenome               mensagem\n1   Ana    Santos  Boa noite Ana Santos!\n2 Maria     Silva Boa noite Maria Silva!\n3  João     Souza  Boa noite João Souza!\n4  <NA>      <NA>       Boa noite NA NA!\n```\n:::\n:::\n\n\nOutra opção para a qual utilizamavamos o `paste`, era para unir todos os elementos de uma string, utilizando o argumento `collapse`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$nome %>% \n  paste(., collapse = \", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ana, Maria, João, NA\"\n```\n:::\n:::\n\n\nUma alternativa é utilizarmos a função `str_flatten`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$nome %>% \n  str_flatten(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"AnaMariaJoão\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$nome %>% \n  str_flatten(na.rm = TRUE, collapse = \", \", last = \" e \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Ana, Maria e João\"\n```\n:::\n:::\n\n\n### 4.9.3 Separando Strings\n\nMuitas vezes precisamos separar uma string em duas (ou mais). Na aula passada vimos a função `separate`. Hoje vamos ver a `str_split`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %<>% \n  mutate(Nome_Sobrenome = str_c(nome, sobrenome, sep = \" \"))\n\ndf$Nome_Sobrenome %>% \n  str_split(., \" \", simplify = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]    [,2]    \n[1,] \"Ana\"   \"Santos\"\n[2,] \"Maria\" \"Silva\" \n[3,] \"João\"  \"Souza\" \n[4,] NA      \"\"      \n```\n:::\n:::\n\n\n### 4.9.4 Formatação básica\n\nMuitas vezes queremos passar um texto para caixa alta, caixa baixa, título ou até mesmo formato de sentença. Para isso podemos utilizar as funções: `str_to_upper()`, `str_to_lower()`, `str_to_title()` e `str_to_sentence()` respectivamente.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto_exemplo = c(\"caixa baixa\", \"CAIXA ALTA\", \"Texto de sentença\", \"Texto Em Título\")\nstr_to_lower(texto_exemplo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"caixa baixa\"       \"caixa alta\"        \"texto de sentença\"\n[4] \"texto em título\"  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_sentence(texto_exemplo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Caixa baixa\"       \"Caixa alta\"        \"Texto de sentença\"\n[4] \"Texto em título\"  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_title(texto_exemplo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Caixa Baixa\"       \"Caixa Alta\"        \"Texto De Sentença\"\n[4] \"Texto Em Título\"  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_upper(texto_exemplo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CAIXA BAIXA\"       \"CAIXA ALTA\"        \"TEXTO DE SENTENÇA\"\n[4] \"TEXTO EM TÍTULO\"  \n```\n:::\n:::\n\n\nAlgumas vezes recebemos um texto desformatado, no sentido de conter diversos espaços no meio do texto. E temos interesse em limpar os excessos de espaço. Para isso podemos utilizar as seguintes funções: `str_trim()` e `str_squish()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto_com_espaços = \"  Olá, esse texto tem    diversos        espaços completamente desnecessários. \"\n\nstr_trim(texto_com_espaços, side = \"left\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Olá, esse texto tem    diversos        espaços completamente desnecessários. \"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_trim(texto_com_espaços, side = \"right\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"  Olá, esse texto tem    diversos        espaços completamente desnecessários.\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_trim(texto_com_espaços, side = \"both\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Olá, esse texto tem    diversos        espaços completamente desnecessários.\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_squish(texto_com_espaços)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Olá, esse texto tem diversos espaços completamente desnecessários.\"\n```\n:::\n:::\n\n\n### 4.9.5 Comprimento de string\n\nMuitas vezes temos interesse em encontrar textos incorretos em um banco de dados, uma maneira de identificar essas observações é simplesmente por contar a quantidade de caracteres de uma string. Para isso podemos utilizar a função `str_length()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(comprimento_nome = str_length(nome))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   nome sobrenome Nome_Sobrenome comprimento_nome\n1   Ana    Santos     Ana Santos                3\n2 Maria     Silva    Maria Silva                5\n3  João     Souza     João Souza                4\n4  <NA>      <NA>           <NA>               NA\n```\n:::\n:::\n\n\n\nAlternativamente podemos estar interessados em contar a quantidade de caracteres especificos. Para isso, utilizamos a função `str_count()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(qtd_a = str_count(nome, \"a\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   nome sobrenome Nome_Sobrenome qtd_a\n1   Ana    Santos     Ana Santos     1\n2 Maria     Silva    Maria Silva     2\n3  João     Souza     João Souza     0\n4  <NA>      <NA>           <NA>    NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(qtd_vogais = str_count(nome, \"[aeiou]\")) %>%\n  mutate(qtd_consoantes = str_count(nome, \"[^aeiou]\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   nome sobrenome Nome_Sobrenome qtd_vogais qtd_consoantes\n1   Ana    Santos     Ana Santos          1              2\n2 Maria     Silva    Maria Silva          3              2\n3  João     Souza     João Souza          2              2\n4  <NA>      <NA>           <NA>         NA             NA\n```\n:::\n:::\n\n\n### 4.9.6 Substituição de strings\n\nAlgumas vezes podemos estar interessados em substituir alguma string por outra. Para isso podemos utilizar a função `str_replace()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(nome = str_replace(nome, \"ã\", \"a\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   nome sobrenome Nome_Sobrenome\n1   Ana    Santos     Ana Santos\n2 Maria     Silva    Maria Silva\n3  Joao     Souza     João Souza\n4  <NA>      <NA>           <NA>\n```\n:::\n:::\n\n\n\nOutras vezes queremos simplesmente remover algum caracter. Para isso utilizamos a função `str_remove()` para remover a primeira instância do caracter ou `str_remove_all()` para remover todas as instâncias.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(nome = str_remove(nome, \"[aeiouã]\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  nome sobrenome Nome_Sobrenome\n1   An    Santos     Ana Santos\n2 Mria     Silva    Maria Silva\n3  Jão     Souza     João Souza\n4 <NA>      <NA>           <NA>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(nome = str_remove_all(nome, \"[aeiouã]\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  nome sobrenome Nome_Sobrenome\n1   An    Santos     Ana Santos\n2   Mr     Silva    Maria Silva\n3    J     Souza     João Souza\n4 <NA>      <NA>           <NA>\n```\n:::\n:::\n\n\n### 4.9.7 Expressões Regulares\n\nExpressões regulares, muitas vezes abreviadas como “RegEx” são padrões de texto que descrevem conjuntos de *strings*. Elas são amplamente utilizadas para realizar operações de busca, correspondência e manipulação de *strings* em linguagens de programação e ferramentas de processamento de texto, incluindo R. Alguns símbolos e conceitos-chave em expressões regulares:\n\n1. **Literais:** Caracteres literais correspondem a si mesmos. Por exemplo, a regex “abc” corresponderá à sequência “abc” em uma string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto <- \"O gato é um animal adorável.\"\npadrao <- \"gato\"\nstr_detect(texto, padrao)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n2. **Meta-caracteres:** São caracteres com significados especiais em regex. Alguns exemplos incluem:\n\n  * `.` (ponto): Corresponde a qualquer caractere, exceto uma nova linha.\n  * `*`: Corresponde a zero ou mais ocorrências do caractere ou grupo anterior.\n  * `+`: Corresponde a uma ou mais ocorrências do caractere ou grupo anterior.\n  * `?`: Corresponde a zero ou uma ocorrência do caractere ou grupo anterior.\n  * `[]`: Define uma classe de caracteres. Por exemplo, `[aeiou]` corresponde a qualquer vogal.\n  * `|` (barra vertical): Funciona como um “OU” lógico. Por exemplo, “a|b” corresponde a “a” ou “b”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto <- c(\"O rato correu para o buraco.\", \n           \"O gato correu para o buraco.\",\n           \"O mato.\")\npadrao <- \"(g|r)ato\"\nstr_detect(texto, padrao)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\n3. **Âncoras**: São usadas para ancorar padrões em posições específicas da string.\n  * `^`: Corresponde ao início da string.\n  * `$`: Corresponde ao final da string.\n  * `\\b`: Corresponde a uma borda de palavra (início ou fim de uma palavra).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto <- c(\"Banana\", \"Ana\", \"Ananas\")\npadrao <- \"^ana\"\nstr_detect(texto, padrao)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Ignorar case\nstr_detect(texto, \"(?i)ana\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Ignorar case, terminar com ana\nstr_detect(texto, \"(?i)ana$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Ignorar case, começar com ana\nstr_detect(texto, \"(?i)^ana\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Ignorar case, exatamente  ana\nstr_detect(texto, \"(?i)^ana$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE\n```\n:::\n:::\n\n\n4. **Grupos**: Parênteses `()` são usados para agrupar caracteres em subexpressões. Isso é útil para aplicar operadores a um conjunto de caracteres.\n  * Exemplo: `(abc)+` corresponde a “abc”, “abcabc”, “abcabcabc”, etc.\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract(texto, \"(na)+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"nana\" \"na\"   \"nana\"\n```\n:::\n:::\n\n  \n5. **Quantificadores**: Controlam o número de ocorrências de um caractere ou grupo.\n  * `{n}`: Corresponde exatamente a n ocorrências.\n  * `{n,}`: Corresponde a pelo menos n ocorrências.\n  * `{n,m}`: Corresponde de n a m ocorrências.\n  \n\n::: {.cell}\n\n```{.r .cell-code}\ntexto <- \"Os números 123 e 456 são importantes.\"\npadrao <- \"\\\\d{3}\"\nnumeros <- str_extract_all(texto, padrao, simplify = TRUE)\nnumeros\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]  [,2] \n[1,] \"123\" \"456\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntexto <- \"Os números 123, 456 e 78 são importantes.\"\npadrao <- \"\\\\d{2}\"\nnumeros <- str_extract_all(texto, padrao, simplify = TRUE)\nnumeros\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,] \"12\" \"45\" \"78\"\n```\n:::\n:::\n\n\n### 4.9.8 Exercício\n\nUtilizando os dados disponíveis em `words` crie RegEx capaz de encontrar palavras que:\n\n1. Comece com “y”.\n\n2. Não comece com “y”.\n\n3. Termine com “x”.\n\n4. Tenham exatamente três letras.\n\n5. Tenham sete letras ou mais.\n\n6. Contenham um par vogal-consoante.\n\n7. Contenham pelo menos dois pares vogal-consoante consecutivos.\n\nPara cada um dos desafios a seguir, tente resolvê-los usando tanto uma única expressão regular quanto uma combinação de várias chamadas de `str_detect()`:\n\n1. Encontre todas as palavras que começam ou terminam com “x”.\n\n2. Encontre todas as palavras que começam com uma vogal e terminam com uma consoante.\n\n3. Existem palavras que contêm pelo menos uma de cada vogal diferente?\n\n4. Em `colors()` existem diversos modificadores de cores como *light* e *dark*. Crie um banco contendo o nome da cor original e o nome sem o modificador.\n\n## 4.10 Cheatsheets\n\n* [TidyR](https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf)\n\n* [Manipulando dados](https://github.com/rstudio/cheatsheets/blob/main/translations/portuguese/data-wrangling_pt.pdf)\n\n* [Lubridate](https://github.com/rstudio/cheatsheets/blob/main/lubridate.pdf)\n\n* [Strings](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf)\n\n* [RegEx](https://github.com/rstudio/cheatsheets/blob/main/regex.pdf)\n\n* [Para saber mais sobre RegEx](https://regexr.com/)\n\n* Jogo de palavra cruzadas em [RegEx](https://regexcrossword.com/).\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}