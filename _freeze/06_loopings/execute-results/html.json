{
  "hash": "d3e48a208c93d38fcf148cf8cb4875cc",
  "result": {
    "markdown": "---\nalways_allow_html: true\ntitle: \"6  Estruturas de Repetição: *Loopings*\"\n---\n\n\nAs estruturas de repetição desempenham um papel crucial na programação, pois permitem que tarefas repetitivas sejam realizadas de maneira mais eficaz ou iterem sobre conjuntos de dados extensos. Além disso, as estruturas de repetição são essenciais para processar grandes volumes de dados, realizar cálculos complexos e criar algoritmos mais poderosos.\n\nEm R existem diversas estruturas de repetição, veremos aqui: `while`, `for` e a família `apply`.\n\n### 6.0.1 Estrutura `while` \n\nO loop while é uma das estruturas de repetição mais simples. Ele é usado quando você precisa repetir um bloco de código *enquanto uma condição for verdadeira*. E seu critério de parada é atualizado, i.e., você não sabe de imediato quantas vezes vai precisar repetir o procedimento.\n\nA estrutura básica do while é a seguinte:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile (condicao) {\n  # Código a ser repetido enquanto a condição for verdadeira\n}\n```\n:::\n\n\nImprima na tela `i`, enquanto `i` for menor do que `6`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1 # sempre definimos o critério de parada fora do loop\n\nwhile (i < 6) {\n  print(i)\n  i <- i + 1 # Sempre alteramos o critério \n  # de parada, senão caímos em um loop infinito\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n:::\n\n\n#### 6.0.1.1 `Break` \n\nMesmo quando uma condição é verdadeira, podemos ter interesse em parar uma repetição, mesmo que a condição seja `TRUE`. Útil quando não queremos cair em um loop infinito.\n\nPor exemplo, podemos parar o nosso loop caso nosso `i == 4`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\nwhile (i < 6) {\n  print(i)\n  i <- i + 1\n  if (i == 4) {\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n```\n:::\n:::\n\n\n### 6.0.1.2 `Next`\n\nOutras vezes, podemos pular uma iteração sem encerrar o loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 0\nwhile (i < 6) {\n  i <- i + 1\n  if (i == 3) {\n    next\n  }\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 4\n[1] 5\n[1] 6\n```\n:::\n:::\n\n\n### 6.0.2 Exercício\n\nSuponha o lançamento de um dado não viesado, com seis faces. Quantas vezes devo lançar o dado para obter a face 5?\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\ndado <- seq(1:6)\nn_lancamento = 0\nsorteio = 0\n\nwhile (sorteio != 5) {\n  sorteio =  sample(dado, 1)\n  n_lancamento = n_lancamento + 1\n  \n  cat(paste0(\"\\n\\nLançamento: \", n_lancamento, \"\\nValor Sorteado: \", sorteio))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\nLançamento: 1\nValor Sorteado: 4\n\nLançamento: 2\nValor Sorteado: 2\n\nLançamento: 3\nValor Sorteado: 6\n\nLançamento: 4\nValor Sorteado: 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn_lancamento\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn_lancamento = 0\nwhile (sorteio != 7) {\n  sorteio =  sample(dado, 1)\n  n_lancamento = n_lancamento + 1\n  \n  cat(paste0(\"\\n\\nLançamento: \", n_lancamento, \"\\nValor Sorteado: \", sorteio))\n  \n  if(n_lancamento == 20){\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\nLançamento: 1\nValor Sorteado: 4\n\nLançamento: 2\nValor Sorteado: 1\n\nLançamento: 3\nValor Sorteado: 5\n\nLançamento: 4\nValor Sorteado: 6\n\nLançamento: 5\nValor Sorteado: 4\n\nLançamento: 6\nValor Sorteado: 2\n\nLançamento: 7\nValor Sorteado: 6\n\nLançamento: 8\nValor Sorteado: 2\n\nLançamento: 9\nValor Sorteado: 6\n\nLançamento: 10\nValor Sorteado: 6\n\nLançamento: 11\nValor Sorteado: 4\n\nLançamento: 12\nValor Sorteado: 6\n\nLançamento: 13\nValor Sorteado: 6\n\nLançamento: 14\nValor Sorteado: 6\n\nLançamento: 15\nValor Sorteado: 4\n\nLançamento: 16\nValor Sorteado: 4\n\nLançamento: 17\nValor Sorteado: 5\n\nLançamento: 18\nValor Sorteado: 4\n\nLançamento: 19\nValor Sorteado: 3\n\nLançamento: 20\nValor Sorteado: 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn_lancamento\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n\nNote que em ambos exemplos os valores estão sendo apenas calculados e não estamos guardando em nenhuma variável. Para resolver esse problema podemos simplesmnet guardar o valor sorteado em um vetor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_sorteado = numeric()\nn_lancamento = 0\nwhile (sorteio != 7) {\n  n_lancamento = n_lancamento + 1\n  valor_sorteado[n_lancamento] =  sample(dado, 1)\n  \n  \n  cat(paste0(\"\\n\\nLançamento: \", n_lancamento, \"\\nValor Sorteado: \", sorteio))\n  \n  if(n_lancamento == 20){\n    break\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\nLançamento: 1\nValor Sorteado: 4\n\nLançamento: 2\nValor Sorteado: 4\n\nLançamento: 3\nValor Sorteado: 4\n\nLançamento: 4\nValor Sorteado: 4\n\nLançamento: 5\nValor Sorteado: 4\n\nLançamento: 6\nValor Sorteado: 4\n\nLançamento: 7\nValor Sorteado: 4\n\nLançamento: 8\nValor Sorteado: 4\n\nLançamento: 9\nValor Sorteado: 4\n\nLançamento: 10\nValor Sorteado: 4\n\nLançamento: 11\nValor Sorteado: 4\n\nLançamento: 12\nValor Sorteado: 4\n\nLançamento: 13\nValor Sorteado: 4\n\nLançamento: 14\nValor Sorteado: 4\n\nLançamento: 15\nValor Sorteado: 4\n\nLançamento: 16\nValor Sorteado: 4\n\nLançamento: 17\nValor Sorteado: 4\n\nLançamento: 18\nValor Sorteado: 4\n\nLançamento: 19\nValor Sorteado: 4\n\nLançamento: 20\nValor Sorteado: 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_sorteado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 5 2 5 2 6 3 4 4 3 1 3 6 4 2 3 2 5 6 1 6\n```\n:::\n:::\n\n\n### 6.0.3 Estrutura `for`\n\nO loop `for` é usado para iterar sobre uma sequência de valores, como um vetor ou uma lista. A estrutura básica é a seguinte:\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (variavel in sequencia) {\n  # Código a ser executado para cada valor da sequência\n}\n```\n:::\n\n\nSuponha que queremos calcular o quadrado dos valores de 1:10. Para isso, podemos utilizar um `for`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:10) {\n  x1 <- i^2\n  print(x1)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n[1] 36\n[1] 49\n[1] 64\n[1] 81\n[1] 100\n```\n:::\n:::\n\n\nAlém disso, podemos ter `for` aninhados.\n\nSuponha agora um experimento que consiste no lançamento de dois dados não viesados de seis faces, e definimos uma variável aleatória como o quadrado da soma das faces superiores dos dois dados. Queremos guardar o valor dos dois dados, a soma das faces superiores e o quadrado da soma.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: dplyr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(magrittr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: magrittr\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndado = c(1:6)\nsoma_dois_dados = function(dado1, dado2){\n  soma = dado1 + dado2\n  \n}\nquadrado_soma = function(soma){\n  soma2 = soma^2\n  return(soma2)\n}\n\nresultado = list()\nk = 0 \nfor(i in dado){\n  for(j in dado){\n    k = k + 1\n    soma = soma_dois_dados(dado[i], dado[j])\n    somaqd = quadrado_soma(soma)\n    \n    resultado[[k]] = data.frame(dado1 = dado[i], \n                               dado2 = dado[j], \n                               soma = soma, \n                               soma2 = somaqd)\n  }\n}\n\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n  dado1 dado2 soma soma2\n1     1     1    2     4\n\n[[2]]\n  dado1 dado2 soma soma2\n1     1     2    3     9\n\n[[3]]\n  dado1 dado2 soma soma2\n1     1     3    4    16\n\n[[4]]\n  dado1 dado2 soma soma2\n1     1     4    5    25\n\n[[5]]\n  dado1 dado2 soma soma2\n1     1     5    6    36\n\n[[6]]\n  dado1 dado2 soma soma2\n1     1     6    7    49\n\n[[7]]\n  dado1 dado2 soma soma2\n1     2     1    3     9\n\n[[8]]\n  dado1 dado2 soma soma2\n1     2     2    4    16\n\n[[9]]\n  dado1 dado2 soma soma2\n1     2     3    5    25\n\n[[10]]\n  dado1 dado2 soma soma2\n1     2     4    6    36\n\n[[11]]\n  dado1 dado2 soma soma2\n1     2     5    7    49\n\n[[12]]\n  dado1 dado2 soma soma2\n1     2     6    8    64\n\n[[13]]\n  dado1 dado2 soma soma2\n1     3     1    4    16\n\n[[14]]\n  dado1 dado2 soma soma2\n1     3     2    5    25\n\n[[15]]\n  dado1 dado2 soma soma2\n1     3     3    6    36\n\n[[16]]\n  dado1 dado2 soma soma2\n1     3     4    7    49\n\n[[17]]\n  dado1 dado2 soma soma2\n1     3     5    8    64\n\n[[18]]\n  dado1 dado2 soma soma2\n1     3     6    9    81\n\n[[19]]\n  dado1 dado2 soma soma2\n1     4     1    5    25\n\n[[20]]\n  dado1 dado2 soma soma2\n1     4     2    6    36\n\n[[21]]\n  dado1 dado2 soma soma2\n1     4     3    7    49\n\n[[22]]\n  dado1 dado2 soma soma2\n1     4     4    8    64\n\n[[23]]\n  dado1 dado2 soma soma2\n1     4     5    9    81\n\n[[24]]\n  dado1 dado2 soma soma2\n1     4     6   10   100\n\n[[25]]\n  dado1 dado2 soma soma2\n1     5     1    6    36\n\n[[26]]\n  dado1 dado2 soma soma2\n1     5     2    7    49\n\n[[27]]\n  dado1 dado2 soma soma2\n1     5     3    8    64\n\n[[28]]\n  dado1 dado2 soma soma2\n1     5     4    9    81\n\n[[29]]\n  dado1 dado2 soma soma2\n1     5     5   10   100\n\n[[30]]\n  dado1 dado2 soma soma2\n1     5     6   11   121\n\n[[31]]\n  dado1 dado2 soma soma2\n1     6     1    7    49\n\n[[32]]\n  dado1 dado2 soma soma2\n1     6     2    8    64\n\n[[33]]\n  dado1 dado2 soma soma2\n1     6     3    9    81\n\n[[34]]\n  dado1 dado2 soma soma2\n1     6     4   10   100\n\n[[35]]\n  dado1 dado2 soma soma2\n1     6     5   11   121\n\n[[36]]\n  dado1 dado2 soma soma2\n1     6     6   12   144\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado %<>% bind_rows()\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   dado1 dado2 soma soma2\n1      1     1    2     4\n2      1     2    3     9\n3      1     3    4    16\n4      1     4    5    25\n5      1     5    6    36\n6      1     6    7    49\n7      2     1    3     9\n8      2     2    4    16\n9      2     3    5    25\n10     2     4    6    36\n11     2     5    7    49\n12     2     6    8    64\n13     3     1    4    16\n14     3     2    5    25\n15     3     3    6    36\n16     3     4    7    49\n17     3     5    8    64\n18     3     6    9    81\n19     4     1    5    25\n20     4     2    6    36\n21     4     3    7    49\n22     4     4    8    64\n23     4     5    9    81\n24     4     6   10   100\n25     5     1    6    36\n26     5     2    7    49\n27     5     3    8    64\n28     5     4    9    81\n29     5     5   10   100\n30     5     6   11   121\n31     6     1    7    49\n32     6     2    8    64\n33     6     3    9    81\n34     6     4   10   100\n35     6     5   11   121\n36     6     6   12   144\n```\n:::\n:::\n\n\n### 6.0.4 Família apply\n\nA família de funções apply em R inclui `apply()`, `lapply()`, `sapply()`, `vapply()`, `tapply()`, `mapply()`, entre outras. Essas funções são usadas para aplicar uma função a elementos de uma lista, vetor, matriz ou array. Ela funciona similar ao `for` em termos de repetições.\n\n* `apply()`: Aplica uma função qualquer a uma matriz, array ou data.frame ao longo de margens específicas (linhas `1` ou colunas `2`). O output de um `apply()` é um vetor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatriz1 <- matrix(1:6, nrow = 2)\nsoma_linhas <- apply(matriz1, 1, sum)\nsoma_colunas <- apply(matriz1, 2, sum)\n```\n:::\n\n\n* `lapply()`: Aplica uma função a cada elemento de uma lista e retorna uma lista com os resultados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nminha_lista <- list(a = c(1, 2, 3), b = c(4, 5, 6))\nresultados <- lapply(minha_lista, mean)\nresultados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 2\n\n$b\n[1] 5\n```\n:::\n:::\n\n\n* `sapply()`: A função sapply() é semelhante ao lapply(), mas tenta simplificar o resultado em um vetor ou matriz sempre que possível. Se todos os resultados forem do mesmo comprimento, será retornado um vetor. Caso contrário, será retornada uma matriz.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nminha_lista <- list(a = c(1, 2, 3), b = c(4, 5, 6), c=c(7,6,8))\nresultados <- sapply(minha_lista, mean)\nresultados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b c \n2 5 7 \n```\n:::\n:::\n\n\n* `mapply()`: Aplica uma função a vários argumentos. Ele oferece uma maneira eficiente de realizar essas operações de forma flexível e controlada.\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- mapply(soma_dois_dados, \n                    dado, \n                    dado)\n\nprint(resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10 12\n```\n:::\n:::\n\n\nE se eu quisesse somar *todas as combinações* como no `for` aninhado? Para isso podemos expandir o grid de busca, utilizando o `expand.grid`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndois_dados = expand.grid(dado, dado)\ndois_dados\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Var1 Var2\n1     1    1\n2     2    1\n3     3    1\n4     4    1\n5     5    1\n6     6    1\n7     1    2\n8     2    2\n9     3    2\n10    4    2\n11    5    2\n12    6    2\n13    1    3\n14    2    3\n15    3    3\n16    4    3\n17    5    3\n18    6    3\n19    1    4\n20    2    4\n21    3    4\n22    4    4\n23    5    4\n24    6    4\n25    1    5\n26    2    5\n27    3    5\n28    4    5\n29    5    5\n30    6    5\n31    1    6\n32    2    6\n33    3    6\n34    4    6\n35    5    6\n36    6    6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- mapply(soma_dois_dados, \n                    dois_dados$Var1, \n                    dois_dados$Var2)\n\nprint(resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  3  4  5  6  7  3  4  5  6  7  8  4  5  6  7  8  9  5  6  7  8  9 10  6\n[26]  7  8  9 10 11  7  8  9 10 11 12\n```\n:::\n:::\n\n\n## 6.1 Exercícios\n\n1. Crie uma função que calcule os `n` primeiros números da sequência de Fibonacci. A sequência de Fibonacci começa com 0 e 1, e os números subsequentes são a soma dos dois anteriores (0, 1, 1, 2, 3, 5, 8, …).\n\n::: {.cell}\n\n```{.r .cell-code}\ncalcular_fibonacci <- function(n) {\n  fibonacci_sequence <- numeric(n)\n  \n  if (n >= 1) {\n    fibonacci_sequence[1] <- 0\n  }\n  if (n >= 2) {\n    fibonacci_sequence[2] <- 1\n  }\n  \n  for (i in 3:n) {\n    fibonacci_sequence[i] <- fibonacci_sequence[i - 1] + fibonacci_sequence[i - 2]\n  }\n  \n  return(fibonacci_sequence)\n}\n\n# Exemplo de uso\nn <- 10\nresultado <- calcular_fibonacci(n)\ncat(\"Os primeiros\", n, \"números da sequência de Fibonacci são:\", resultado, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOs primeiros 10 números da sequência de Fibonacci são: 0 1 1 2 3 5 8 13 21 34 \n```\n:::\n:::\n\n\n2. Crie uma função que verifique se um número `n` é primo.\n\n::: {.cell}\n\n```{.r .cell-code}\neh_primo <- function(n) {\n  if (n <= 1) {\n    return(FALSE)\n  }\n  \n  for (i in 2:(n-1)) {\n    if (n %% i == 0) {\n      return(FALSE)\n    }\n  }\n  \n  return(TRUE)\n}\n\n# Exemplos de uso\nnumeros_exemplos <- c(13, 25, 7, 4, 19)\n\nfor (numero in numeros_exemplos) {\n  if (eh_primo(numero)) {\n    cat(numero, \"é um número primo.\\n\")\n  } else {\n    cat(numero, \"não é um número primo.\\n\")\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13 é um número primo.\n25 não é um número primo.\n7 é um número primo.\n4 não é um número primo.\n19 é um número primo.\n```\n:::\n:::\n\n\n\n\n3. Calcule o 1o. e 2o. Quartil para todas as variáveis numéricas de `mtcars`. Se uma variável não for numérica retorne `NA`. Lembre-se `cyl`, `vs` e `am` são categóricas, e não numéricas.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transformar cyl, vs e am para character\ndados <- mtcars\n\ndados$cyl <- as.character(dados$cyl)\ndados$vs <- as.character(dados$vs)\ndados$am <- as.character(dados$am)\n\n# Função para calcular 1º e 2º quartil para variáveis numéricas\ncalcular_quartis <- function(variavel) {\n  if (is.numeric(variavel)) {\n    quartis <- quantile(variavel, c(0.25, 0.5))\n    return(c(quartil_1 = quartis[1], quartil_2 = quartis[2]))\n  } else {\n    return(c(quartil_1 = NA, quartil_2 = NA))\n  }\n}\n\n# Aplicar a função a todas as colunas de mtcars\nresultados_quartis <- sapply(mtcars, calcular_quartis)\n\n# Mostrar os resultados\nprint(resultados_quartis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 mpg cyl    disp    hp  drat      wt    qsec vs am gear carb\nquartil_1.25% 15.425   4 120.825  96.5 3.080 2.58125 16.8925  0  0    3    2\nquartil_2.50% 19.200   6 196.300 123.0 3.695 3.32500 17.7100  0  0    4    2\n```\n:::\n:::\n\n\n## 6.2 Paralelização\n\nA paralelização de código é uma técnica utilizada para melhorar a eficiência de programas, especialmente quando lidamos com tarefas intensivas em processamento.\n\n### 6.2.1 Por que Paralelizar um Código? \n\nA paralelização é necessária para aproveitar ao máximo os recursos de *hardware* disponíveis e melhorar o desempenho de um programa.\n\n1. **Aproveitamento de Recursos**: A maioria dos computadores modernos possui processadores multi-core, o que significa que eles têm várias unidades de processamento disponíveis. Para aproveitar ao máximo esses recursos, podemos dividir uma tarefa em partes menores que podem ser executadas simultaneamente em diferentes núcleos do processador.\n\n2. **Redução de Tempo de Execução**: Tarefas que seriam demoradas se executadas em sequência podem ser aceleradas significativamente por meio da paralelização. Isso é especialmente importante em tarefas que envolvem grandes conjuntos de dados ou cálculos complexos.\n\n3. **Melhoria da Escalabilidade**: Em situações onde a carga de trabalho pode variar, a paralelização permite que o programa adapte a quantidade de recursos necessários. Quando há mais trabalho a ser feito, mais *threads*[^1] ou processos paralelos podem ser alocados para acelerar o processamento.\n\n\n4. **Resposta em Tempo Real**: Em certos cenários, como em sistemas de controle ou simulações em tempo real, a paralelização pode ser necessária para garantir que as respostas sejam geradas dentro de limites de tempo estritos.\n\n### 6.2.2 Quando Precisamos Paralelizar um Código? \n\nNem todos os programas precisam ser paralelizados. A decisão de quando paralelizar um código depende de vários fatores, incluindo:\n\n1. **Natureza da Tarefa**: Tarefas que podem ser divididas em partes independentes são candidatas naturais para a paralelização. Por exemplo, cálculos em um grande conjunto de dados podem ser paralelizados porque os dados podem ser divididos entre várias unidades de processamento.\n\n2. **Recursos Disponíveis**: A paralelização é mais eficaz quando há recursos de hardware adequados, como processadores multi-core ou clusters de computadores disponíveis. Paralelizar em um ambiente com apenas um núcleo de CPU pode não resultar em benefícios significativos.\n\n3. **Tempo de Execução Crítico**: Se o tempo de execução de um programa é crítico e precisa ser reduzido para cumprir prazos ou requisitos de desempenho, a paralelização pode ser uma solução viável.\n\n4. **Complexidade Computacional**: Tarefas que envolvem cálculos intensivos ou operações repetitivas podem se beneficiar da paralelização para acelerar o processamento.\n\n5. **Escalabilidade Futura**: Se você prevê que a carga de trabalho aumentará no futuro, a paralelização pode ser implementada desde o início para garantir que o programa possa lidar com cargas maiores.\n\n### 6.2.3 Importante\n\n* *Threads* são unidades de execução dentro de um processo, enquanto multiprocessadores são sistemas de *hardware* com vários processadores independentes.\n\n* *Threads* compartilham o mesmo espaço de endereço, enquanto processadores em um multiprocessador executam tarefas independentes com seus próprios espaços de endereço.\n\n### 6.2.4 Medindo a Qualidade da Paralelização\n\n1. **Speedup**: O speedup é uma medida que compara o tempo de execução de um programa paralelizado com o tempo de execução do mesmo programa executado de forma sequencial (em um único processador). O speedup é calculado da seguinte forma:\n$$s = \\frac{Tempo \\ Sequencial}{Tempo \\ em \\ Paralelo}$$\n \n    * Um *speedup* de 2, por exemplo, indica que o programa paralelizado é duas vezes mais rápido do que o programa sequencial.\n\n2. **Eficiência**: A eficiência é uma medida relacionada ao speedup, mas considera o fator de escalabilidade. Ela é calculada como a razão entre o speedup e o número de threads ou processadores utilizados:\n$$E = \\frac{S}{numero \\ de \\ threads}$$\n \n    * A eficiência ideal é 1, o que significa que a adição de mais threads ou processadores resulta em um aumento proporcional no desempenho.\n  \n    * O cálculo da eficiência não leva em consideração o tempo gasto para iniciar e encerrar as threads ou processos, chamado de overhead de paralelização. Em algumas situações, o overhead pode ser significativo e afetar a eficiência geral.\n\n## 6.3 Paralelização em R \n\nExistem inúmeras bibliotecas capazes de paralelizar códigos em R. As principais são: `parallel`, `doParallel` e a `foreach`. A primeira opção é a mais poderosa e vem integrada com o R, portanto, será o nosso foco aqui.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(parallel)\n\n# Quantos cores disponíveis?\ndetectCores()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cria um cluster de processos com 4 núcleos\ncluster <- makeCluster(4)\n\n# Define uma função que será executada em paralelo\nfuncao <- function(x) {\n  return(x^2)\n}\n\n# Distribui a tarefa entre os processos no cluster (roda e espera)\nresultados <- clusterApply(cluster, 1:10, funcao)\n\n# Distribui a tarefa entre os processos no cluster (roda sem espera)\nresultados2 <- clusterApplyLB(cluster, 1:10, funcao)\n\n\n# Encerra o cluster\nstopCluster(cluster)\n\n# Resultados contêm os resultados das operações executadas em paralelo\nprint(resultados)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 9\n\n[[4]]\n[1] 16\n\n[[5]]\n[1] 25\n\n[[6]]\n[1] 36\n\n[[7]]\n[1] 49\n\n[[8]]\n[1] 64\n\n[[9]]\n[1] 81\n\n[[10]]\n[1] 100\n```\n:::\n:::\n\n\nA função `clusterCall()` permite que você execute uma função em paralelo em todos os processos de um cluster e recolha os resultados.\n\n::: {.cell}\n\n```{.r .cell-code}\ncl <- makeCluster(4)\n## Chama a função em paralelo, \n## todas as vezes com os mesmos argumentos\nclusterCall(cl, funcao, 1:10) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1]   1   4   9  16  25  36  49  64  81 100\n\n[[2]]\n [1]   1   4   9  16  25  36  49  64  81 100\n\n[[3]]\n [1]   1   4   9  16  25  36  49  64  81 100\n\n[[4]]\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Exporta para todas as threads \n## os objetos\nclusterExport(cl, \"funcao\")\n\n\nfc <- function(a,b){\n  return(a+b)\n}\nclusterExport(cl, \"fc\")\n## Avalia a função nos argumentos definidos\n## Cada thread re-avalia o resultado, mesmos argumentos\nclusterEvalQ(cl, fc(1:10,1:10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1]  2  4  6  8 10 12 14 16 18 20\n\n[[2]]\n [1]  2  4  6  8 10 12 14 16 18 20\n\n[[3]]\n [1]  2  4  6  8 10 12 14 16 18 20\n\n[[4]]\n [1]  2  4  6  8 10 12 14 16 18 20\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Avalia a função nos argumentos definidos\n## Cada thread re-avalia o resultado, argumentos distintos\nclusterMap(cl, fc, 1:10, 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 8\n\n[[5]]\n[1] 10\n\n[[6]]\n[1] 12\n\n[[7]]\n[1] 14\n\n[[8]]\n[1] 16\n\n[[9]]\n[1] 18\n\n[[10]]\n[1] 20\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstopCluster(cl)\n```\n:::\n\n\n## 6.4 Exercícios\nUtilizando os dados `GlobalIndicators`, agrupe os **países** em duas categorias: alto e baixo. A primeira categoria deve conter os países com o último HDI > 0.7, a segunda os demais. Em seguida, para todas as variáveis (com excessão das HDIs) calcule: a média, a mediana, o desvio padrão e o intervalo interquartilíco. Teste se há diferença entre os dois grupos para cada uma das variáveis.\n\n*  \n    * Dicas: Crie uma função que receba como argumento o grupo e uma variável.\n \n    * Verifique se a distribuição é normal, utilize o `shapiro.test()`. Caso seja, utilize um teste-t (`t.test()`), caso contrário, utilize o teste de Mann-Whitney (`wilcox.test(..., paired = F)`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(data.table)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: data.table\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'data.table'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n```\n:::\n\n```{.r .cell-code}\nrequire(dplyr)\nrequire(tidyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCarregando pacotes exigidos: tidyr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'tidyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:magrittr':\n\n    extract\n```\n:::\n\n```{.r .cell-code}\nrequire(magrittr)\n\nco2 = data.table::fread(\"./datasets/GlobalIndicators/co2_production.csv\")\ngni = data.table::fread(\"./datasets/GlobalIndicators/gross_national_income_per_capital.csv\")\nhdi = data.table::fread(\"./datasets/GlobalIndicators/human_development_index.csv\")\nle = data.table::fread(\"./datasets/GlobalIndicators/life_expectancy_by_birth.csv\")\n\ndf = full_join(co2, gni) %>% \n  full_join(hdi %>% \n              select(ISO3, Country, hdi_2021)) %>% \n  full_join(le) %>% \n  filter(ISO3 != \"\") %>% \n  mutate(grupo = ifelse(hdi_2021 > 0.7, \"Alto\", \"Baixo\")) %>%\n  select(-c(ISO3, Country, hdi_2021, hdicode, region, hdi_rank_2021)) %>% \n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(ISO3, Country, hdicode, region, hdi_rank_2021)`\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(ISO3, Country)`\nJoining with `by = join_by(ISO3, Country, hdicode, region, hdi_rank_2021)`\n```\n:::\n\n```{.r .cell-code}\ncalcula = function(i, grupo = df$grupo){\n  media   = mean(df[,i], na.rm = TRUE)\n  mediana = median(df[,i], na.rm = TRUE)\n  desvio  = sd(df[,i], na.rm = TRUE)\n  interq = IQR(df[,i], na.rm = TRUE)\n  \n  \n  ### Testando Normalidade por grupo\n  norm_alto = shapiro.test(df[ grupo == \"Alto\",i])\n  norm_baixo = shapiro.test(df[grupo == \"Baixo\",i])\n  \n  p_norm_alto = norm_alto$p.value\n  p_norm_baixo = norm_baixo$p.value\n  \n  ## Se ambos forem normais, então fazer o teste t\n  if(all(p_norm_alto > 0.05, p_norm_baixo > 0.05)){\n    ptest = t.test(df[,i] ~ grupo)$p.value\n    test = \"t-test\"\n  } else{\n    ptest = wilcox.test(df[,i] ~ grupo, paired = F)$p.value\n    test = \"Mann Whitney\"\n  }\n  \n  # Resultado a ser impresso\n  resultado = data.frame(media = media, \n                         desvio = desvio, \n                         mediana = mediana, \n                         interq = interq, \n                         shapiro_alto = p_norm_alto, \n                         shapiro_baixo = p_norm_baixo,\n                         test = test, \n                         ptest = ptest\n  )\n  return(resultado)\n}\n\n## Fazendo a versão em paralelo\nrequire(parallel)\ncl <- parallel::makeCluster(4)\nclusterExport(cl, \"df\")\nt1 = Sys.time() \nresults = clusterApply(cl, 1:96, calcula)\nt2 = Sys.time()\nt2-t1 ## Calcula o tempo gasto\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 0.5153158 secs\n```\n:::\n\n```{.r .cell-code}\nresults %<>% bind_rows() ## Transforma o resultado em um df\nstopCluster(cl)\n\n## Fazendo a mesma coisa utilizando for\nresultado2 = list()\nt1_for = Sys.time()\nfor(i in 1:96){\n  resultado2[[i]] = calcula(i)\n}\nt2_for = Sys.time()\nt2_for-t1_for\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 0.2630382 secs\n```\n:::\n:::\n\n\n[^1]: Uma **thread** é uma unidade básica de processamento que pode ser executada em um programa. Ela é uma sequência de instruções que pode ser executada pelo processador de um computador.\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}